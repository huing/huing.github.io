<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | huing的博客</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - huing的博客">
<meta name="author" content="huing">
<link rel="canonical" href="https://huing.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fbdbe883ca626e8b61876263e9d63faf275b95fd7f85b6d38fd7f4c863d14329.css" integrity="sha256-&#43;9vog8pibothh2Jj6dY/rydblf1/hbbTj9f0yGPRQyk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://huing.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://huing.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://huing.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://huing.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://huing.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://huing.github.io/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://huing.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://huing.github.io/posts/">
  <meta property="og:site_name" content="huing的博客">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="huing的个人博客">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="huing的个人博客">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://huing.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://huing.github.io/" accesskey="h" title="huing的博客 (Alt + H)">huing的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://huing.github.io/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://huing.github.io/">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">重排重绘
    </h2>
  </header>
  <div class="entry-content">
    <p>浏览器渲染过程 浏览器渲染页面的基本流程如下:
解析 HTML 构建 DOM 树(DOM Tree) 解析 CSS 构建 CSSOM 树(CSS Object Model) 将 DOM 树和 CSSOM 树合并成渲染树(Render Tree) 布局(Layout):计算每个节点在屏幕中的确切位置和大小 绘制(Paint):将渲染树的每个节点转换成屏幕上的实际像素 重排(Reflow) 什么是重排 重排是指当 DOM 的变化影响了元素的几何信息(位置和尺寸)时，浏览器需要重新计算元素的几何属性，并重新排列它们的位置。这个过程也被称为回流。
触发重排的操作 DOM 元素的增加、删除或位置改变 DOM 元素的尺寸改变（包括外边距、内边距、边框厚度、宽度、高度等） 页面渲染初始化 浏览器窗口尺寸改变 元素字体大小变化 激活 CSS 伪类（例如：:hover） 查询某些属性或调用某些方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft getComputedStyle() getBoundingClientRect() 重绘(Repaint) 什么是重绘 重绘是指当元素的外观发生改变，但没有改变布局时，浏览器会重新绘制元素。重绘的代价较重排小。
触发重绘的操作 修改背景色、文字颜色、边框颜色等 visibility outline box-shadow border-radius 性能优化建议 批量修改 DOM // 不推荐 const el = document.getElementById(&#34;test&#34;); el.style.padding = &#34;5px&#34;; el.style.borderLeft = &#34;1px&#34;; el.style.borderRight = &#34;2px&#34;; // 推荐 const el = document....</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 14:02:41 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;160 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 重排重绘" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E9%87%8D%E6%8E%92%E9%87%8D%E7%BB%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">预加载和onload
    </h2>
  </header>
  <div class="entry-content">
    <p>预加载 和 window.onload 的区别 使用 预加载关键资源 &lt;link rel=&#34;preload&#34; href=&#34;/styles/main.css&#34; as=&#34;style&#34;&gt; &lt;link rel=&#34;preload&#34; href=&#34;/script/main.js&#34; as=&#34;script&#34;&gt; 图片预加载 const img = new Image(); img.src = &#34;图片URL&#34;; // 提前加载图片到缓存 脚本预加载 使用 async 属性：并行请求脚本，尽快解析和执行 使用 defer 属性：在文档解析后、DOMContentLoaded 事件前执行 DOMContentLoaded 事件 DOMContentLoaded 事件在 DOM 树构建完成后立即触发,此时:
HTML 已经被完全加载和解析 DOM 树已经构建完成 外部资源(如图片、样式表等)可能还未完全加载 必须使用 addEventListener 来监听该事件 示例代码:
document.addEventListener(&#34;DOMContentLoaded&#34;, function () { // DOM 已准备就绪,可以安全地操作 DOM 元素 console.log(&#34;DOM 已加载完成&#34;); }); window.onload 事件 window.onload 事件会在页面完全加载后触发,包括:
DOM 树构建完成 所有外部资源加载完成(图片、样式表、脚本等) 所有 iframe 加载完成 示例代码:...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 13:50:59 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;310 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 预加载和onload" href="https://huing.github.io/posts/javascript/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8Conload/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">浏览器的渲染过程
    </h2>
  </header>
  <div class="entry-content">
    <p>浏览器的渲染过程 浏览器渲染网页是一个复杂的过程，主要包含以下几个关键步骤：
1. 浏览器的主要组件 浏览器由以下核心组件构成：
用户界面 - 包括地址栏、前进/后退按钮、书签菜单等 浏览器引擎 - 在用户界面和渲染引擎之间传送指令 渲染引擎 - 负责显示请求的内容 网络组件 - 处理网络请求 UI 后端 - 用于绘制基本的窗口小部件 JavaScript 解释器 - 用于解析和执行 JavaScript 代码 数据存储 - 包括 Cookie、LocalStorage 等机制 2. 渲染过程的主要步骤 2.1 解析 HTML 浏览器开始解析 HTML 文档 构建 DOM（文档对象模型）树 DOM 树反映了 HTML 文档的层级结构 2.2 获取外部资源 解析过程中遇到外部资源（CSS、JavaScript、图片等）时会发起请求 CSS 文件是渲染阻塞资源 JavaScript 可能是解析阻塞资源 2.3 构建 CSSOM 解析 CSS 文件 构建 CSSOM（CSS 对象模型）树 CSSOM 树包含页面中的所有样式信息 2.4 执行 JavaScript 解析和执行 JavaScript 代码 可能会修改 DOM 和 CSSOM JavaScript 执行会阻塞 DOM 构建 2....</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 10:11:08 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;234 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 浏览器的渲染过程" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">浏览器的缓存机制
    </h2>
  </header>
  <div class="entry-content">
    <p>浏览器的缓存机制 浏览器缓存是一种在本地存储资源副本的机制,可以显著提高网站的访问速度,减少服务器负载和带宽消耗。
1. 缓存类型 1.1 私有缓存 存储在用户浏览器中的缓存 只能被单个用户使用 通常存储个性化内容 1.2 共享缓存 可以被多个用户共享的缓存 包括代理缓存和托管缓存(如 CDN) 通常用于存储公共资源 2. HTTP 缓存控制头部 2.1 强缓存 强缓存允许客户端直接从本地缓存中获取资源,无需向服务器发起请求。主要通过以下头部控制:
Expires (HTTP/1.0)
指定资源的过期时间(绝对时间) 受限于客户端与服务器时间不同步的问题 Cache-Control (HTTP/1.1)
max-age: 指定资源有效期 no-cache: 强制验证缓存 no-store: 禁止缓存 private/public: 指定缓存作用域 2.2 协商缓存 当强缓存失效时,浏览器需要与服务器协商验证资源是否更新。主要有两种方式:
Last-Modified/If-Modified-Since
基于资源的最后修改时间 精确度受限于时间戳 ETag/If-None-Match
基于资源的指纹标识 更精确的验证机制 优先级高于 Last-Modified 3. 启发式缓存 当服务器响应没有明确指定缓存策略时,浏览器会采用启发式缓存:
计算公式: (当前时间 - Last-Modified) * 0.1 在此期间浏览器会使用本地缓存 建议始终明确指定 Cache-Control 来避免启发式缓存 4. 最佳实践 静态资源策略
使用长期的强缓存 文件名包含内容哈希 当内容更新时更改文件名 HTML 文档策略
使用 no-cache 或较短的 max-age 配合 ETag 进行协商缓存 API 响应策略...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 10:10:53 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;466 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 浏览器的缓存机制" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">事件循环
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是进程，什么是线程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。简单来说，进程就是程序的一次执行实例。当你运行一个程序时，操作系统会为该程序创建一个进程。
线程（Thread）是操作系统能够进行运算调度的最小单位，被包含在进程之中。一个进程可以包含多个线程。线程是程序执行流的最小单元，负责实际的计算工作。
进程特点 独立的内存空间：每个进程都有自己独立的内存空间，互不干扰 拥有系统资源：进程拥有独立的系统资源，如文件句柄、网络连接等 相互独立：一个进程的崩溃通常不会影响其他进程 通信成本高：进程间通信(IPC)需要特殊的机制，如管道、消息队列等 创建和销毁开销大：需要分配和回收系统资源 线程特点 共享所属进程的内存空间：同一进程内的线程共享进程的内存空间 共享进程资源：共享进程的代码段、数据段等资源 执行开销小：创建和切换线程的成本远低于进程 通信方便：线程间可以直接读写进程的共享数据 相互影响：一个线程崩溃可能导致整个进程崩溃 进程与线程的关系 一个进程至少包含一个线程（主线程） 线程是进程中的实际执行单位 同一进程中的线程共享进程的资源 进程是资源分配的最小单位，线程是 CPU 调度的最小单位 事件循环 Event Loop 事件循环是 JavaScript 实现异步的核心机制。JavaScript 是单线程的语言，但通过事件循环实现了非阻塞的异步执行模型。
核心概念 调用栈(Call Stack)
JavaScript 代码执行的地方 函数调用形成栈帧 遵循后进先出(LIFO)原则 同一时间只能执行一个任务 堆(Heap)
存储对象的内存区域 代码运行时分配的内存空间 由垃圾回收器管理 任务队列(Task Queue)
存储待执行的回调函数 遵循先进先出(FIFO)原则 分为宏任务队列和微任务队列 事件循环的执行流程 执行同步代码，同步代码进入调用栈立即执行 遇到异步任务时，将其交给相应的 Web API 处理 Web API 处理完成后，将回调函数放入任务队列 当调用栈为空时，事件循环检查任务队列 将任务队列中的任务按顺序放入调用栈执行 重复以上步骤 任务类型 宏任务(MacroTask) 宏任务是由标准 JavaScript 引擎机制提供的任务，它们会被放入消息队列中等待主线程执行。当一个宏任务执行时：
V8 引擎会建立新的执行栈来存储任务 执行不同的函数调用时栈会随之变化 当该宏任务执行结束时，会清空当前的栈 常见的宏任务包括：
script(整体代码): JavaScript 脚本的初始化执行属于第一个宏任务 事件回调 setTimeout/setInterval 回调 setImmediate(Node....</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 07:43:15 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;160 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 事件循环" href="https://huing.github.io/posts/javascript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">React的diff算法
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是虚拟 dom Virtual DOM 则是一种由 Javascript 类库基于浏览器 API 实现的概念
虚拟 dom 就是用 js 对象来描述 dom 结构。
diff 算法 仅右移 const oldVdom = { type: &#39;div&#39;, props: { children: [] } children: [ { type: &#39;p&#39;, props: {} children: [] }, { type: &#39;p&#39;, props: {} } ] } const newVdom = { type: &#39;div&#39;, props: {} children: [ { type: &#39;p&#39;, props: {} }, { type: &#39;p&#39;, props: {} } ] } function diff(oldVdom, newVdom) { if (oldVdom....</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-28 07:57:28 +0800 CST'>2025-03-28</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;105 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to React的diff算法" href="https://huing.github.io/posts/react/react%E7%9A%84diff%E7%AE%97%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Vue
    </h2>
  </header>
  <div class="entry-content">
    <p>vue-router 路由守卫 路由原理 beforeEnter(to, from, next) {} vue 响应式数据 原理 数组更新
vuex 和 pinia 响应式数据原理区别 vuex 和 pinia 区别是什么
架构设计 Vuex 基于模块化设计，使用 mutations、actions、modules 等概念 Pinia 采用更简单的 Store 设计，没有 mutations，直接使用 actions 进行状态修改 Pinia 的 Store 可以直接定义，不需要像 Vuex 那样创建复杂的模块树 TypeScript 支持 Pinia 是用 TypeScript 编写的，提供了更好的类型推导和类型安全 Vuex 对 TypeScript 的支持相对较弱，需要额外的类型声明 开发体验 Pinia 支持多个 Store，可以相互独立 Pinia 的 devtools 调试体验更好 Pinia 代码更简洁，不需要写 mutations Pinia 支持自动代码分割（code splitting） 性能 Pinia 体积更小，打包后约 1KB Pinia 没有嵌套模块，扁平化设计使得性能更好 Vue 版本支持 Pinia 同时支持 Vue 2 和 Vue 3 Vuex 4 只支持 Vue 3，Vuex 3 只支持 Vue 2 // Vuex 示例 const store = new Vuex....</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-25 09:35:37 +0800 CST'>2025-03-25</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;162 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to Vue" href="https://huing.github.io/posts/vue/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Stack
    </h2>
  </header>
  <div class="entry-content">
    <p>Queue 先进先出 class Queue { constructor() { this.items = []; // 用于存储队列元素的数组 } // 入队方法 - 在队列尾部添加元素 enqueue(element) { this.items.push(element); } // 出队方法 - 移除并返回队列头部的元素 dequeue() { if (this.isEmpty()) { return &#34;队列为空&#34;; } return this.items.shift(); } // 查看队列头部的元素 peek() { if (this.isEmpty()) { return &#34;队列为空&#34;; } return this.items[0]; } // 检查队列是否为空 isEmpty() { return this.items.length === 0; } // 返回队列的大小 size() { return this.items.length; } // 清空队列 clear() { this.items = []; } // 打印队列内容 print() { console....</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-24 14:11:14 +0800 CST'>2025-03-24</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;263 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to Stack" href="https://huing.github.io/posts/javascript/stack/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Canvas
    </h2>
  </header>
  <div class="entry-content">
    <p>Canvas 基础概念 Canvas 是 HTML5 提供的用于在网页上绘制图形的元素。它可以用于绘制图表、制作图片合成或者实现基础的动画效果。
基本用法 创建 Canvas 元素 获取绘图上下文(Context) 使用 Canvas API 进行绘制 常见绘图操作 绘制形状(矩形、圆形、路径等) 添加颜色和样式 绘制文本 图片操作 变换(平移、旋转、缩放) Canvas API 实例 1. 基础图形绘制 // 获取Canvas上下文 const canvas = document.getElementById(&#34;myCanvas&#34;); const ctx = canvas.getContext(&#34;2d&#34;); // 绘制矩形 ctx.fillStyle = &#34;red&#34;; // 设置填充颜色 ctx.fillRect(10, 10, 100, 50); // x, y, width, height // 绘制圆形 ctx.beginPath(); ctx.arc(100, 100, 50, 0, Math.PI * 2); // x, y, 半径, 起始角度, 结束角度 ctx.fillStyle = &#34;blue&#34;; ctx....</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-23 11:53:04 +0800 CST'>2025-03-23</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;758 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to Canvas" href="https://huing.github.io/posts/html/canvas/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">EventBus
    </h2>
  </header>
  <div class="entry-content">
    <p>实现一个 EventBus 发布/订阅设计模式 EventBus 是 一个事件总线，它允许多个组件之间进行通信。 在 javascript 中，我们可以使用一个类来表示 EventBus。
class EventBus { constructor() { this.events = {}; } on(eventName, callback) { if (!this.events[eventName]) { this.events[eventName] = []; } this.events[eventName].push(callback); } off(eventName, callback) { if (!this.events[eventName]) { return; } if (callback) { this.events[eventName] = this.events[eventName].filter( (cb) =&gt; cb !== callback ); } else { delete this.events[eventName]; } } emit(eventName, ...args) { if (!this.events[eventName]) { return; } this.events[eventName].forEach((callback) =&gt; { callback(...args); }); } once(eventName, callback) { const onceCallback = (....</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-19 09:34:28 +0800 CST'>2025-03-19</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;89 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to EventBus" href="https://huing.github.io/posts/javascript/eventbus/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://huing.github.io/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://huing.github.io/">huing的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
