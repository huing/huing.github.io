<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>互联网 | huing的博客</title>
<meta name="keywords" content="">
<meta name="description" content="huing的个人博客">
<meta name="author" content="huing">
<link rel="canonical" href="https://huing.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fbdbe883ca626e8b61876263e9d63faf275b95fd7f85b6d38fd7f4c863d14329.css" integrity="sha256-&#43;9vog8pibothh2Jj6dY/rydblf1/hbbTj9f0yGPRQyk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://huing.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://huing.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://huing.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://huing.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://huing.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://huing.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/index.xml">
<link rel="alternate" hreflang="en" href="https://huing.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://huing.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/">
  <meta property="og:site_name" content="huing的博客">
  <meta property="og:title" content="互联网">
  <meta property="og:description" content="huing的个人博客">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="互联网">
<meta name="twitter:description" content="huing的个人博客">

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://huing.github.io/" accesskey="h" title="huing的博客 (Alt + H)">huing的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://huing.github.io/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://huing.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://huing.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://huing.github.io/tags/">Tags</a></div>
  <h1>
    互联网
    <a href="/tags/%E4%BA%92%E8%81%94%E7%BD%91/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">重排重绘
    </h2>
  </header>
  <div class="entry-content">
    <p>浏览器渲染过程 浏览器渲染页面的基本流程如下:
解析 HTML 构建 DOM 树(DOM Tree) 解析 CSS 构建 CSSOM 树(CSS Object Model) 将 DOM 树和 CSSOM 树合并成渲染树(Render Tree) 布局(Layout):计算每个节点在屏幕中的确切位置和大小 绘制(Paint):将渲染树的每个节点转换成屏幕上的实际像素 重排(Reflow) 什么是重排 重排是指当 DOM 的变化影响了元素的几何信息(位置和尺寸)时，浏览器需要重新计算元素的几何属性，并重新排列它们的位置。这个过程也被称为回流。
触发重排的操作 DOM 元素的增加、删除或位置改变 DOM 元素的尺寸改变（包括外边距、内边距、边框厚度、宽度、高度等） 页面渲染初始化 浏览器窗口尺寸改变 元素字体大小变化 激活 CSS 伪类（例如：:hover） 查询某些属性或调用某些方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft getComputedStyle() getBoundingClientRect() 重绘(Repaint) 什么是重绘 重绘是指当元素的外观发生改变，但没有改变布局时，浏览器会重新绘制元素。重绘的代价较重排小。
触发重绘的操作 修改背景色、文字颜色、边框颜色等 visibility outline box-shadow border-radius 性能优化建议 批量修改 DOM // 不推荐 const el = document.getElementById(&#34;test&#34;); el.style.padding = &#34;5px&#34;; el.style.borderLeft = &#34;1px&#34;; el.style.borderRight = &#34;2px&#34;; // 推荐 const el = document....</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 14:02:41 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;160 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 重排重绘" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E9%87%8D%E6%8E%92%E9%87%8D%E7%BB%98/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">浏览器的渲染过程
    </h2>
  </header>
  <div class="entry-content">
    <p>浏览器的渲染过程 浏览器渲染网页是一个复杂的过程，主要包含以下几个关键步骤：
1. 浏览器的主要组件 浏览器由以下核心组件构成：
用户界面 - 包括地址栏、前进/后退按钮、书签菜单等 浏览器引擎 - 在用户界面和渲染引擎之间传送指令 渲染引擎 - 负责显示请求的内容 网络组件 - 处理网络请求 UI 后端 - 用于绘制基本的窗口小部件 JavaScript 解释器 - 用于解析和执行 JavaScript 代码 数据存储 - 包括 Cookie、LocalStorage 等机制 2. 渲染过程的主要步骤 2.1 解析 HTML 浏览器开始解析 HTML 文档 构建 DOM（文档对象模型）树 DOM 树反映了 HTML 文档的层级结构 2.2 获取外部资源 解析过程中遇到外部资源（CSS、JavaScript、图片等）时会发起请求 CSS 文件是渲染阻塞资源 JavaScript 可能是解析阻塞资源 2.3 构建 CSSOM 解析 CSS 文件 构建 CSSOM（CSS 对象模型）树 CSSOM 树包含页面中的所有样式信息 2.4 执行 JavaScript 解析和执行 JavaScript 代码 可能会修改 DOM 和 CSSOM JavaScript 执行会阻塞 DOM 构建 2....</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 10:11:08 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;234 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 浏览器的渲染过程" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">浏览器的缓存机制
    </h2>
  </header>
  <div class="entry-content">
    <p>浏览器的缓存机制 浏览器缓存是一种在本地存储资源副本的机制,可以显著提高网站的访问速度,减少服务器负载和带宽消耗。
1. 缓存类型 1.1 私有缓存 存储在用户浏览器中的缓存 只能被单个用户使用 通常存储个性化内容 1.2 共享缓存 可以被多个用户共享的缓存 包括代理缓存和托管缓存(如 CDN) 通常用于存储公共资源 2. HTTP 缓存控制头部 2.1 强缓存 强缓存允许客户端直接从本地缓存中获取资源,无需向服务器发起请求。主要通过以下头部控制:
Expires (HTTP/1.0)
指定资源的过期时间(绝对时间) 受限于客户端与服务器时间不同步的问题 Cache-Control (HTTP/1.1)
max-age: 指定资源有效期 no-cache: 强制验证缓存 no-store: 禁止缓存 private/public: 指定缓存作用域 2.2 协商缓存 当强缓存失效时,浏览器需要与服务器协商验证资源是否更新。主要有两种方式:
Last-Modified/If-Modified-Since
基于资源的最后修改时间 精确度受限于时间戳 ETag/If-None-Match
基于资源的指纹标识 更精确的验证机制 优先级高于 Last-Modified 3. 启发式缓存 当服务器响应没有明确指定缓存策略时,浏览器会采用启发式缓存:
计算公式: (当前时间 - Last-Modified) * 0.1 在此期间浏览器会使用本地缓存 建议始终明确指定 Cache-Control 来避免启发式缓存 4. 最佳实践 静态资源策略
使用长期的强缓存 文件名包含内容哈希 当内容更新时更改文件名 HTML 文档策略
使用 no-cache 或较短的 max-age 配合 ETag 进行协商缓存 API 响应策略...</p>
  </div>
  <footer class="entry-footer"><span title='2025-04-03 10:10:53 +0800 CST'>2025-04-03</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;466 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 浏览器的缓存机制" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">渲染
    </h2>
  </header>
  <div class="entry-content">
    <p>side rendering
ssr ssr 是什么
ssg
esr
rsr
docker lpass jenkins node cdn 静态托管
nextjs(react)
nuxtjs(vue)
bff 网关
k8s v8s
服务器，镜像，容器
webpack5 module federation 模块联邦，webpack5 的一个新特性，可实现跨应用共享代码
MicroApp 、single-spa、qiankuan
无服务器（Serverless）
RPC 远程过程调用（英语：Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC 是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统
云计算的三种模式 云计算模式所具备的 5 个基本特征（按需自助服务、广泛的网络访问、资源共享、快速的可伸缩性和可度量的服务）、3 种服务模式 SaaS（软件即服务）、PaaS（平台即服务）和 IaaS（基础设施即服务）和 4 种部署方式（私有云、社区云、公有云和混合云），而云服务则是在这个云平台上发布出来的供用户使用的产品服务
IaaS（Infrastructure as a server） 基础设施即服务
PaaS（Platform as a Server） 平台即服务
SaaS（Software as a Server） 软件即服务
区别和关系 云计算(Cloud Computing) 是一种概念和技术，提供按需的计算资源和服务。 云服务(Cloud Service) 是云计算的具体实现形式，包括 IaaS、PaaS 和 SaaS 等不同类型的云服务。 云函数(Cloud Function) 是一种特定的云服务类型，属于&#34;无服务器计算&#34;(Serverless) 模型，适用于事件驱动的任务。 云计算（概念和技术模型） ├── 云服务（具体实现形式） │ ├── IaaS │ ├── PaaS │ └── SaaS └── 云函数（特定服务类型） └── Serverless 的一种实现...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-03 07:27:41 +0800 CST'>2024-09-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;95 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 渲染" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E5%95%A5/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">浏览器的工作原理
    </h2>
  </header>
  <div class="entry-content">
    <p>HeadlessBrowser Headless Browser(无头浏览器)是一种没有图形用户界面(GUI)的浏览器，可以在后台运行并通过程序代码控制。
主要特点 无界面运行：在服务器等没有图形界面的环境中运行 完整功能：支持 JavaScript 执行、DOM 操作等完整的浏览器功能 自动化支持：可以通过代码完全控制浏览器行为 性能优势：相比传统浏览器占用更少的系统资源 应用场景 自动化测试
端到端测试(E2E Testing) 界面功能测试 跨浏览器兼容性测试 网页爬虫
抓取动态网页内容 模拟用户行为 处理需要 JavaScript 渲染的页面 网页截图与 PDF 生成
自动化网页截图 生成网页 PDF 报告 页面内容导出 性能监控
页面加载性能分析 资源使用情况监控 网络请求追踪 常用实现 Chrome Headless const puppeteer = require(&#34;puppeteer&#34;); (async () =&gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&#34;https://example.com&#34;); await page.screenshot({ path: &#34;screenshot.png&#34; }); await browser.close(); })(); Firefox Headless const firefox = require(&#34;selenium-webdriver/firefox&#34;); const options = new firefox....</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-03 06:49:36 +0800 CST'>2024-09-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;187 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 浏览器的工作原理" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">网络是如何连接的
    </h2>
  </header>
  <div class="entry-content">
    <p>网络是如何连接的 浏览器处理流程 当我们在浏览器中输入一个 URL(如www.example.com)后,浏览器会经过以下步骤:
解析 URL
识别协议(http/https) 识别域名(example.com) 识别资源路径(/) DNS 解析过程
首先检查浏览器 DNS 缓存 检查操作系统 DNS 缓存 检查路由器缓存 向 ISP 的 DNS 服务器发起递归查询 获取目标服务器的 IP 地址 建立连接
与目标服务器建立 TCP 连接(三次握手) 如果是 HTTPS,还需要进行 TLS 握手 发送 HTTP 请求
浏览器构建 HTTP 请求报文 通过网络发送到服务器 浏览器渲染过程
解析 HTML 构建 DOM 树(DOM Tree) 解析 CSS 构建 CSSOM(CSS Object Model) 合并 DOM 和 CSSOM 构建渲染树(Render Tree) 布局(Layout):计算每个节点的几何信息 绘制(Painting):将渲染树绘制到屏幕上 DNS (Domain Name System) 原理 DNS 是一个分布式数据库,主要功能是将域名转换为 IP 地址。解析过程如下:...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-03 06:45:36 +0800 CST'>2024-09-03</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;344 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to 网络是如何连接的" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">CDN原理
    </h2>
  </header>
  <div class="entry-content">
    <p>内容分发网络 cdn Content Delivery Network cache-control</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-03 06:43:54 +0800 CST'>2024-09-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;huing</footer>
  <a class="entry-link" aria-label="post link to CDN原理" href="https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/cdn%E5%8E%9F%E7%90%86/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://huing.github.io/">huing的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
