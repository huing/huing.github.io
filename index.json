[{"content":"我的博客\nGithub 地址 github\n邮箱地址\n","permalink":"https://huing.github.io/about/","summary":"我的博客\nGithub 地址 github\n邮箱地址","title":"关于"},{"content":"浏览器渲染过程 浏览器渲染页面的基本流程如下:\n解析 HTML 构建 DOM 树(DOM Tree) 解析 CSS 构建 CSSOM 树(CSS Object Model) 将 DOM 树和 CSSOM 树合并成渲染树(Render Tree) 布局(Layout):计算每个节点在屏幕中的确切位置和大小 绘制(Paint):将渲染树的每个节点转换成屏幕上的实际像素 重排(Reflow) 什么是重排 重排是指当 DOM 的变化影响了元素的几何信息(位置和尺寸)时，浏览器需要重新计算元素的几何属性，并重新排列它们的位置。这个过程也被称为回流。\n触发重排的操作 DOM 元素的增加、删除或位置改变 DOM 元素的尺寸改变（包括外边距、内边距、边框厚度、宽度、高度等） 页面渲染初始化 浏览器窗口尺寸改变 元素字体大小变化 激活 CSS 伪类（例如：:hover） 查询某些属性或调用某些方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft getComputedStyle() getBoundingClientRect() 重绘(Repaint) 什么是重绘 重绘是指当元素的外观发生改变，但没有改变布局时，浏览器会重新绘制元素。重绘的代价较重排小。\n触发重绘的操作 修改背景色、文字颜色、边框颜色等 visibility outline box-shadow border-radius 性能优化建议 批量修改 DOM // 不推荐 const el = document.getElementById(\u0026#34;test\u0026#34;); el.style.padding = \u0026#34;5px\u0026#34;; el.style.borderLeft = \u0026#34;1px\u0026#34;; el.style.borderRight = \u0026#34;2px\u0026#34;; // 推荐 const el = document.getElementById(\u0026#34;test\u0026#34;); el.style.cssText = \u0026#34;padding: 5px; border-left: 1px; border-right: 2px;\u0026#34;; 避免频繁操作样式 // 不推荐 const element = document.getElementById(\u0026#34;test\u0026#34;); element.style.left = \u0026#34;10px\u0026#34;; element.style.top = \u0026#34;10px\u0026#34;; element.style.width = \u0026#34;20px\u0026#34;; // 推荐 element.classList.add(\u0026#34;newStyle\u0026#34;); 使用文档片段(DocumentFragment) const fragment = document.createDocumentFragment(); for (let i = 0; i \u0026lt; 10; i++) { const el = document.createElement(\u0026#34;p\u0026#34;); el.innerHTML = \u0026#34;test\u0026#34;; fragment.appendChild(el); } document.body.appendChild(fragment); 对于复杂动画效果，使用绝对定位使其脱离文档流\n避免使用 table 布局，table 中任何一个元素的改变都会造成整个 table 的重新布局\n使用 transform 替代 top/left 位移\n将复杂的节点设置为图层，使用 will-change 或 translate3d 来提升为独立图层\n.element { will-change: transform; /* 或者 */ transform: translate3d(0, 0, 0); } 通过合理的优化策略，我们可以显著减少重排和重绘的次数，从而提升页面性能和用户体验。\n","permalink":"https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E9%87%8D%E6%8E%92%E9%87%8D%E7%BB%98/","summary":"浏览器渲染过程 浏览器渲染页面的基本流程如下:\n解析 HTML 构建 DOM 树(DOM Tree) 解析 CSS 构建 CSSOM 树(CSS Object Model) 将 DOM 树和 CSSOM 树合并成渲染树(Render Tree) 布局(Layout):计算每个节点在屏幕中的确切位置和大小 绘制(Paint):将渲染树的每个节点转换成屏幕上的实际像素 重排(Reflow) 什么是重排 重排是指当 DOM 的变化影响了元素的几何信息(位置和尺寸)时，浏览器需要重新计算元素的几何属性，并重新排列它们的位置。这个过程也被称为回流。\n触发重排的操作 DOM 元素的增加、删除或位置改变 DOM 元素的尺寸改变（包括外边距、内边距、边框厚度、宽度、高度等） 页面渲染初始化 浏览器窗口尺寸改变 元素字体大小变化 激活 CSS 伪类（例如：:hover） 查询某些属性或调用某些方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft getComputedStyle() getBoundingClientRect() 重绘(Repaint) 什么是重绘 重绘是指当元素的外观发生改变，但没有改变布局时，浏览器会重新绘制元素。重绘的代价较重排小。\n触发重绘的操作 修改背景色、文字颜色、边框颜色等 visibility outline box-shadow border-radius 性能优化建议 批量修改 DOM // 不推荐 const el = document.getElementById(\u0026#34;test\u0026#34;); el.style.padding = \u0026#34;5px\u0026#34;; el.style.borderLeft = \u0026#34;1px\u0026#34;; el.style.borderRight = \u0026#34;2px\u0026#34;; // 推荐 const el = document.","title":"重排重绘"},{"content":"预加载 和 window.onload 的区别 使用 预加载关键资源 \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/styles/main.css\u0026#34; as=\u0026#34;style\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/script/main.js\u0026#34; as=\u0026#34;script\u0026#34;\u0026gt; 图片预加载 const img = new Image(); img.src = \u0026#34;图片URL\u0026#34;; // 提前加载图片到缓存 脚本预加载 使用 async 属性：并行请求脚本，尽快解析和执行 使用 defer 属性：在文档解析后、DOMContentLoaded 事件前执行 DOMContentLoaded 事件 DOMContentLoaded 事件在 DOM 树构建完成后立即触发,此时:\nHTML 已经被完全加载和解析 DOM 树已经构建完成 外部资源(如图片、样式表等)可能还未完全加载 必须使用 addEventListener 来监听该事件 示例代码:\ndocument.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { // DOM 已准备就绪,可以安全地操作 DOM 元素 console.log(\u0026#34;DOM 已加载完成\u0026#34;); }); window.onload 事件 window.onload 事件会在页面完全加载后触发,包括:\nDOM 树构建完成 所有外部资源加载完成(图片、样式表、脚本等) 所有 iframe 加载完成 示例代码:\nwindow.onload = function () { // 页面的所有资源都已加载完成 console.log(\u0026#34;页面完全加载完成\u0026#34;); }; 主要区别 触发时机\nDOMContentLoaded: DOM 树构建完成后立即触发 window.onload: 所有资源(包括图片、样式等)加载完成后触发 使用场景\nDOMContentLoaded: 适合进行 DOM 操作、添加事件监听器等不依赖外部资源的操作 window.onload: 适合需要等待所有资源加载完成后的操作,如获取图片尺寸 性能影响\nDOMContentLoaded 通常比 window.onload 更早触发 使用 DOMContentLoaded 可以让页面交互代码更早执行,提升用户体验 实际应用建议 如果代码只需要操作 DOM,建议使用 DOMContentLoaded 如果代码需要处理外部资源(如图片尺寸),则使用 window.onload 可以通过 document.readyState 来检查当前文档加载状态: loading: 文档正在加载 interactive: 文档已被解析完成(等同于 DOMContentLoaded) complete: 文档和所有资源已完成加载(等同于 window.onload) 预加载的使用场景 框架开发中的使用场景 预加载的使用场景 SPA 应用的关键资源预加载 \u0026lt;!-- 预加载首屏必需的 CSS 和 JS --\u0026gt; \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/app.css\u0026#34; as=\u0026#34;style\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/app.js\u0026#34; as=\u0026#34;script\u0026#34; /\u0026gt; 路由懒加载优化 当用户 hover 或即将进入某个路由时，预加载对应的组件资源 适用于 React.lazy、Vue Router 等场景 字体文件预加载 \u0026lt;!-- 预加载自定义字体，避免 FOUT (Flash of Unstyled Text) --\u0026gt; \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/fonts/custom-font.woff2\u0026#34; as=\u0026#34;font\u0026#34; crossorigin /\u0026gt; 首屏关键图片预加载 // 比如轮播图第一张 const img = new Image(); img.src = \u0026#34;banner-1.jpg\u0026#34;; window.onload 的使用场景 Hybrid 应用开发 需要等待页面完全加载后再调用原生方法 控制 WebView 加载进度条的消失时机 复杂数据可视化 window.onload = () =\u0026gt; { // 确保所有资源加载完成后再初始化图表 initCharts(); }; 性能监控 // 记录页面完整加载时间 window.onload = () =\u0026gt; { const loadTime = performance.now(); // 上报加载性能数据 }; 框架开发中的最佳实践 Vue 项目中 // 路由组件的预加载 const Home = () =\u0026gt; import(/* webpackPrefetch: true */ \u0026#39;./views/Home.vue\u0026#39;) // 确保资源加载完成 mounted() { window.onload = () =\u0026gt; { // 初始化需要完整页面资源的操作 } } React 项目中 // 预加载组件 const Component = React.lazy(() =\u0026gt; import(\u0026#34;./Component\u0026#34;)); // 使用 Suspense 处理加载状态 \u0026lt;Suspense fallback={\u0026lt;Loading /\u0026gt;}\u0026gt; \u0026lt;Component /\u0026gt; \u0026lt;/Suspense\u0026gt;; 性能优化场景 使用预加载提升首屏加载速度 通过 Performance API 监控加载性能 // 监控关键性能指标 const performanceMetrics = { loadTime: 0, domContentLoaded: 0, }; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { performanceMetrics.domContentLoaded = performance.now(); }); window.onload = () =\u0026gt; { performanceMetrics.loadTime = performance.now(); }; 注意事项 预加载使用建议 只预加载当前页面必需的资源 避免过度预加载导致带宽浪费 使用 Chrome DevTools 监控预加载资源的使用情况 onload 事件使用建议 避免在 onload 中执行过重的操作 考虑使用 DOMContentLoaded 代替不需要等待所有资源的场景 在 Hybrid 开发中特别注意 onload 的触发时机 ","permalink":"https://huing.github.io/posts/javascript/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8Conload/","summary":"预加载 和 window.onload 的区别 使用 预加载关键资源 \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/styles/main.css\u0026#34; as=\u0026#34;style\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/script/main.js\u0026#34; as=\u0026#34;script\u0026#34;\u0026gt; 图片预加载 const img = new Image(); img.src = \u0026#34;图片URL\u0026#34;; // 提前加载图片到缓存 脚本预加载 使用 async 属性：并行请求脚本，尽快解析和执行 使用 defer 属性：在文档解析后、DOMContentLoaded 事件前执行 DOMContentLoaded 事件 DOMContentLoaded 事件在 DOM 树构建完成后立即触发,此时:\nHTML 已经被完全加载和解析 DOM 树已经构建完成 外部资源(如图片、样式表等)可能还未完全加载 必须使用 addEventListener 来监听该事件 示例代码:\ndocument.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { // DOM 已准备就绪,可以安全地操作 DOM 元素 console.log(\u0026#34;DOM 已加载完成\u0026#34;); }); window.onload 事件 window.onload 事件会在页面完全加载后触发,包括:\nDOM 树构建完成 所有外部资源加载完成(图片、样式表、脚本等) 所有 iframe 加载完成 示例代码:","title":"预加载和onload"},{"content":"浏览器的渲染过程 浏览器渲染网页是一个复杂的过程，主要包含以下几个关键步骤：\n1. 浏览器的主要组件 浏览器由以下核心组件构成：\n用户界面 - 包括地址栏、前进/后退按钮、书签菜单等 浏览器引擎 - 在用户界面和渲染引擎之间传送指令 渲染引擎 - 负责显示请求的内容 网络组件 - 处理网络请求 UI 后端 - 用于绘制基本的窗口小部件 JavaScript 解释器 - 用于解析和执行 JavaScript 代码 数据存储 - 包括 Cookie、LocalStorage 等机制 2. 渲染过程的主要步骤 2.1 解析 HTML 浏览器开始解析 HTML 文档 构建 DOM（文档对象模型）树 DOM 树反映了 HTML 文档的层级结构 2.2 获取外部资源 解析过程中遇到外部资源（CSS、JavaScript、图片等）时会发起请求 CSS 文件是渲染阻塞资源 JavaScript 可能是解析阻塞资源 2.3 构建 CSSOM 解析 CSS 文件 构建 CSSOM（CSS 对象模型）树 CSSOM 树包含页面中的所有样式信息 2.4 执行 JavaScript 解析和执行 JavaScript 代码 可能会修改 DOM 和 CSSOM JavaScript 执行会阻塞 DOM 构建 2.5 构建渲染树 将 DOM 和 CSSOM 合并成渲染树 只包含需要显示的节点 不包含隐藏元素（display: none） 2.6 布局和绘制 布局（Layout）\n计算每个节点的精确位置和大小 确定元素的几何信息 也称为\u0026quot;回流\u0026quot;（Reflow） 绘制（Paint）\n将渲染树转换成屏幕上的实际像素 填充颜色、绘制边框、阴影等 可能包含多个图层 3. 优化渲染性能 3.1 减少重排（Reflow） 避免频繁修改元素大小和位置 批量修改 DOM 使用 transform 代替位置修改 transform 优化示例 传统方式（会触发重排）： /* 不推荐 */ .element { position: absolute; left: 100px; top: 100px; } 优化方式（使用 transform）： /* 推荐 */ .element { transform: translate(100px, 100px); } 动画场景对比： /* 不推荐 - 会触发重排 */ @keyframes moveWithPosition { from { left: 0; top: 0; } to { left: 200px; top: 200px; } } /* 推荐 - 仅触发合成 */ @keyframes moveWithTransform { from { transform: translate(0, 0); } to { transform: translate(200px, 200px); } } 性能优势：\ntransform 不会触发布局重排 transform 会创建新的图层，由 GPU 加速处理 动画帧率更高，性能更好 特别适合移动端性能优化 最佳实践：\n对于需要移动的元素，优先使用 transform 配合 will-change: transform 提前创建图层 动画结束后记得移除 will-change 以释放内存 3.2 减少重绘（Repaint） 使用 CSS3 硬件加速 合理使用图层 避免不必要的样式更改 3.3 资源加载优化 使用异步加载 JavaScript（async/defer） 关键 CSS 内联 延迟加载非关键资源 4. 现代浏览器的优化 多进程架构：每个标签页使用独立进程 硬件加速：利用 GPU 进行渲染 预加载和预解析机制 智能的资源优先级处理 5. 开发者工具 浏览器开发者工具提供了多种功能来分析和优化渲染过程：\nPerformance 面板：分析渲染性能 Layers 面板：查看图层信息 Paint Flashing：显示重绘区域 FPS 计数器：监控帧率 通过理解浏览器的渲染过程，开发者可以更好地优化网页性能，提供更好的用户体验。\n水合 ","permalink":"https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","summary":"浏览器的渲染过程 浏览器渲染网页是一个复杂的过程，主要包含以下几个关键步骤：\n1. 浏览器的主要组件 浏览器由以下核心组件构成：\n用户界面 - 包括地址栏、前进/后退按钮、书签菜单等 浏览器引擎 - 在用户界面和渲染引擎之间传送指令 渲染引擎 - 负责显示请求的内容 网络组件 - 处理网络请求 UI 后端 - 用于绘制基本的窗口小部件 JavaScript 解释器 - 用于解析和执行 JavaScript 代码 数据存储 - 包括 Cookie、LocalStorage 等机制 2. 渲染过程的主要步骤 2.1 解析 HTML 浏览器开始解析 HTML 文档 构建 DOM（文档对象模型）树 DOM 树反映了 HTML 文档的层级结构 2.2 获取外部资源 解析过程中遇到外部资源（CSS、JavaScript、图片等）时会发起请求 CSS 文件是渲染阻塞资源 JavaScript 可能是解析阻塞资源 2.3 构建 CSSOM 解析 CSS 文件 构建 CSSOM（CSS 对象模型）树 CSSOM 树包含页面中的所有样式信息 2.4 执行 JavaScript 解析和执行 JavaScript 代码 可能会修改 DOM 和 CSSOM JavaScript 执行会阻塞 DOM 构建 2.","title":"浏览器的渲染过程"},{"content":"浏览器的缓存机制 浏览器缓存是一种在本地存储资源副本的机制,可以显著提高网站的访问速度,减少服务器负载和带宽消耗。\n1. 缓存类型 1.1 私有缓存 存储在用户浏览器中的缓存 只能被单个用户使用 通常存储个性化内容 1.2 共享缓存 可以被多个用户共享的缓存 包括代理缓存和托管缓存(如 CDN) 通常用于存储公共资源 2. HTTP 缓存控制头部 2.1 强缓存 强缓存允许客户端直接从本地缓存中获取资源,无需向服务器发起请求。主要通过以下头部控制:\nExpires (HTTP/1.0)\n指定资源的过期时间(绝对时间) 受限于客户端与服务器时间不同步的问题 Cache-Control (HTTP/1.1)\nmax-age: 指定资源有效期 no-cache: 强制验证缓存 no-store: 禁止缓存 private/public: 指定缓存作用域 2.2 协商缓存 当强缓存失效时,浏览器需要与服务器协商验证资源是否更新。主要有两种方式:\nLast-Modified/If-Modified-Since\n基于资源的最后修改时间 精确度受限于时间戳 ETag/If-None-Match\n基于资源的指纹标识 更精确的验证机制 优先级高于 Last-Modified 3. 启发式缓存 当服务器响应没有明确指定缓存策略时,浏览器会采用启发式缓存:\n计算公式: (当前时间 - Last-Modified) * 0.1 在此期间浏览器会使用本地缓存 建议始终明确指定 Cache-Control 来避免启发式缓存 4. 最佳实践 静态资源策略\n使用长期的强缓存 文件名包含内容哈希 当内容更新时更改文件名 HTML 文档策略\n使用 no-cache 或较短的 max-age 配合 ETag 进行协商缓存 API 响应策略\n动态内容通常使用 no-store 部分接口可使用短期缓存 5. 缓存清除方式 浏览器强制刷新 代码方式更新资源路径 使用 CDN 清除缓存 服务端设置合适的缓存策略 通过合理配置缓存策略,可以在保证资源时效性的同时,最大化缓存的优势,提升用户体验。\nHTTP Header 重要参数 1. 请求头(Request Headers) 1.1 通用请求头 Accept: 指定客户端能够接收的内容类型 Accept-Encoding: 指定客户端可以接受的内容编码方式 Accept-Language: 指定客户端可以接受的语言 Connection: 指定连接的管理方式（如：keep-alive, close） Host: 指定请求的服务器域名和端口号 User-Agent: 客户端的应用程序信息 1.2 缓存相关请求头 If-Modified-Since: 上次请求时服务器返回的 Last-Modified 值 If-None-Match: 上次请求时服务器返回的 ETag 值 Cache-Control: 指定请求和响应遵循的缓存机制 2. 响应头(Response Headers) 2.1 通用响应头 Content-Type: 返回内容的 MIME 类型 Content-Length: 返回内容的字节长度 Content-Encoding: 返回内容的编码方式 Server: 服务器的信息 2.2 安全相关响应头 Content-Security-Policy: 内容安全策略，防止 XSS 等攻击 X-Frame-Options: 控制页面是否可以被嵌入框架 X-XSS-Protection: XSS 防护设置 Strict-Transport-Security: 强制使用 HTTPS 访问 2.3 跨域相关响应头 Access-Control-Allow-Origin: 指定允许跨域访问的源 Access-Control-Allow-Methods: 允许的 HTTP 方法 Access-Control-Allow-Headers: 允许的自定义请求头 Access-Control-Max-Age: 预检请求的有效期 2.4 缓存相关响应头 ETag: 资源的唯一标识符 Last-Modified: 资源的最后修改时间 Expires: 响应过期的日期和时间 Cache-Control: 缓存控制指令 max-age=\u0026lt;seconds\u0026gt;: 缓存的最大有效时间 public: 可以被任何缓存区缓存 private: 只能被私有缓存缓存 no-cache: 强制验证缓存 no-store: 不允许缓存 3. 实践建议 安全性配置\n始终配置适当的安全响应头 对敏感资源设置严格的缓存控制 合理配置 CORS 策略 性能优化\n合理设置内容压缩 利用缓存控制减少请求 适当配置 keep-alive 连接 调试技巧\n使用浏览器开发者工具监控请求头 通过 curl 或 Postman 测试响应头 定期检查和更新安全相关的响应头 header 里有哪些重要参数 Content-Type 详解 Content-Type 是一个重要的 HTTP 头部字段，用于指定资源的媒体类型（MIME type）。它在请求和响应中都扮演着重要角色。\n1. 基本语法 Content-Type 的基本语法格式为：\nContent-Type: media-type; charset=charset-value 2. 常见的 MIME 类型 2.1 文本类型 text/html: HTML 文档 text/plain: 纯文本 text/css: CSS 样式表 text/javascript: JavaScript 文件 2.2 图片类型 image/jpeg: JPEG 图片 image/png: PNG 图片 image/gif: GIF 图片 image/webp: WebP 图片 image/svg+xml: SVG 图片 2.3 应用程序类型 application/json: JSON 数据 application/xml: XML 数据 application/pdf: PDF 文档 application/x-www-form-urlencoded: 表单数据 application/octet-stream: 二进制文件 2.4 多媒体类型 audio/mpeg: MP3 等音频文件 video/mp4: MP4 视频文件 video/webm: WebM 视频文件 3. 特殊用途 3.1 多部分表单数据 Content-Type: multipart/form-data; boundary=something 用于上传文件的表单提交，其中 boundary 参数用于分隔不同部分的内容。\n3.2 字符编码 Content-Type: text/html; charset=utf-8 charset 参数指定文本内容的字符编码。\n4. 使用注意事项 安全性考虑\n设置 X-Content-Type-Options: nosniff 防止浏览器进行 MIME 类型嗅探 确保 Content-Type 与实际内容相匹配，避免安全风险 性能优化\n正确设置 Content-Type 有助于浏览器正确解析和渲染内容 对于静态资源，建议配置正确的 Content-Type 和缓存策略 常见问题\n文件下载时使用 application/octet-stream API 响应使用 application/json 表单提交使用 application/x-www-form-urlencoded 或 multipart/form-data 调试技巧\n使用浏览器开发者工具检查响应头 确保服务器配置正确的 Content-Type 注意文件扩展名与 MIME 类型的对应关系 强制验证缓存（no-cache）详解 强制验证缓存是一种特殊的缓存控制机制，通过设置 Cache-Control: no-cache 来实现。它的工作方式如下：\n1. 基本原理 允许客户端缓存资源 每次使用缓存前必须向服务器验证资源是否有效 不会直接使用本地缓存 2. 工作流程 首次请求\n客户端 → 服务器：GET /resource 服务器 → 客户端： HTTP/1.1 200 OK Cache-Control: no-cache Last-Modified: Tue, 22 Feb 2022 22:00:00 GMT ETag: \u0026#34;deadbeef\u0026#34; 后续请求\n客户端 → 服务器：GET /resource If-None-Match: \u0026#34;deadbeef\u0026#34; If-Modified-Since: Tue, 22 Feb 2022 22:00:00 GMT 服务器响应\n如果资源未更改：返回 304 Not Modified 如果资源已更改：返回 200 OK 和新内容 3. 与其他缓存指令的区别 no-cache vs no-store\nno-cache: 允许缓存，但必须重新验证 no-store: 完全禁止缓存 no-cache vs max-age=0\nno-cache: 标准的强制验证方式 max-age=0, must-revalidate: 旧版本的替代方案，现已不推荐使用 4. 使用场景 动态内容\n经常更新的 API 响应 个性化的用户数据 需要验证的静态资源\n重要的配置文件 频繁变化的资源 安全性要求\n需要确保内容最新性 但允许合理利用缓存提升性能 5. 配置示例 Nginx 配置\nlocation /api/ { add_header Cache-Control \u0026#34;no-cache\u0026#34;; add_header Last-Modified $date_gmt; add_header ETag $etag; } Express.js 配置\napp.use((req, res, next) =\u0026gt; { res.set(\u0026#34;Cache-Control\u0026#34;, \u0026#34;no-cache\u0026#34;); next(); }); 6. 注意事项 性能考虑\n每次请求都需要与服务器通信 但可以节省带宽（304 响应很小） 适合需要验证但变化不频繁的资源 最佳实践\n配合 ETag 或 Last-Modified 使用 合理设置验证头 考虑使用 CDN 来分担验证请求 ","permalink":"https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","summary":"浏览器的缓存机制 浏览器缓存是一种在本地存储资源副本的机制,可以显著提高网站的访问速度,减少服务器负载和带宽消耗。\n1. 缓存类型 1.1 私有缓存 存储在用户浏览器中的缓存 只能被单个用户使用 通常存储个性化内容 1.2 共享缓存 可以被多个用户共享的缓存 包括代理缓存和托管缓存(如 CDN) 通常用于存储公共资源 2. HTTP 缓存控制头部 2.1 强缓存 强缓存允许客户端直接从本地缓存中获取资源,无需向服务器发起请求。主要通过以下头部控制:\nExpires (HTTP/1.0)\n指定资源的过期时间(绝对时间) 受限于客户端与服务器时间不同步的问题 Cache-Control (HTTP/1.1)\nmax-age: 指定资源有效期 no-cache: 强制验证缓存 no-store: 禁止缓存 private/public: 指定缓存作用域 2.2 协商缓存 当强缓存失效时,浏览器需要与服务器协商验证资源是否更新。主要有两种方式:\nLast-Modified/If-Modified-Since\n基于资源的最后修改时间 精确度受限于时间戳 ETag/If-None-Match\n基于资源的指纹标识 更精确的验证机制 优先级高于 Last-Modified 3. 启发式缓存 当服务器响应没有明确指定缓存策略时,浏览器会采用启发式缓存:\n计算公式: (当前时间 - Last-Modified) * 0.1 在此期间浏览器会使用本地缓存 建议始终明确指定 Cache-Control 来避免启发式缓存 4. 最佳实践 静态资源策略\n使用长期的强缓存 文件名包含内容哈希 当内容更新时更改文件名 HTML 文档策略\n使用 no-cache 或较短的 max-age 配合 ETag 进行协商缓存 API 响应策略","title":"浏览器的缓存机制"},{"content":"什么是进程，什么是线程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。简单来说，进程就是程序的一次执行实例。当你运行一个程序时，操作系统会为该程序创建一个进程。\n线程（Thread）是操作系统能够进行运算调度的最小单位，被包含在进程之中。一个进程可以包含多个线程。线程是程序执行流的最小单元，负责实际的计算工作。\n进程特点 独立的内存空间：每个进程都有自己独立的内存空间，互不干扰 拥有系统资源：进程拥有独立的系统资源，如文件句柄、网络连接等 相互独立：一个进程的崩溃通常不会影响其他进程 通信成本高：进程间通信(IPC)需要特殊的机制，如管道、消息队列等 创建和销毁开销大：需要分配和回收系统资源 线程特点 共享所属进程的内存空间：同一进程内的线程共享进程的内存空间 共享进程资源：共享进程的代码段、数据段等资源 执行开销小：创建和切换线程的成本远低于进程 通信方便：线程间可以直接读写进程的共享数据 相互影响：一个线程崩溃可能导致整个进程崩溃 进程与线程的关系 一个进程至少包含一个线程（主线程） 线程是进程中的实际执行单位 同一进程中的线程共享进程的资源 进程是资源分配的最小单位，线程是 CPU 调度的最小单位 事件循环 Event Loop 事件循环是 JavaScript 实现异步的核心机制。JavaScript 是单线程的语言，但通过事件循环实现了非阻塞的异步执行模型。\n核心概念 调用栈(Call Stack)\nJavaScript 代码执行的地方 函数调用形成栈帧 遵循后进先出(LIFO)原则 同一时间只能执行一个任务 堆(Heap)\n存储对象的内存区域 代码运行时分配的内存空间 由垃圾回收器管理 任务队列(Task Queue)\n存储待执行的回调函数 遵循先进先出(FIFO)原则 分为宏任务队列和微任务队列 事件循环的执行流程 执行同步代码，同步代码进入调用栈立即执行 遇到异步任务时，将其交给相应的 Web API 处理 Web API 处理完成后，将回调函数放入任务队列 当调用栈为空时，事件循环检查任务队列 将任务队列中的任务按顺序放入调用栈执行 重复以上步骤 任务类型 宏任务(MacroTask) 宏任务是由标准 JavaScript 引擎机制提供的任务，它们会被放入消息队列中等待主线程执行。当一个宏任务执行时：\nV8 引擎会建立新的执行栈来存储任务 执行不同的函数调用时栈会随之变化 当该宏任务执行结束时，会清空当前的栈 常见的宏任务包括：\nscript(整体代码): JavaScript 脚本的初始化执行属于第一个宏任务 事件回调 setTimeout/setInterval 回调 setImmediate(Node.js 环境) requestAnimationFrame (浏览器环境) I/O 操作 UI 渲染 DOM 事件 微任务(MicroTask) 微任务是一种需要异步执行的任务，它的执行时机是在当前宏任务结束之后，下一个宏任务开始之前。\nPromise.then/catch/finally process.nextTick(Node.js 环境) MutationObserver 回调 queueMicrotask() 执行优先级 同步代码优先执行 执行当前的宏任务 执行当前宏任务产生的所有微任务 如果微任务执行过程中产生新的微任务，继续执行完所有微任务 当前宏任务结束，微任务队列清空 开始下一个宏任务 每个宏任务之间可能会进行 UI 渲染 示例代码 执行第一个宏任务：script(整体代码) 执行过程中同步代码直接执行 遇到微任务添加到微任务队列 遇到宏任务添加到宏任务队列 当前宏任务执行完毕后，立即执行所有微任务 微任务执行完毕后，开始下一个宏任务 // 这是第一个宏任务：script(整体代码) console.log(\u0026#34;script start\u0026#34;); // 同步代码 setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout\u0026#34;); // 宏任务 }, 0); Promise.resolve() .then(() =\u0026gt; { console.log(\u0026#34;promise1\u0026#34;); // 微任务 }) .then(() =\u0026gt; { console.log(\u0026#34;promise2\u0026#34;); // 微任务 }); console.log(\u0026#34;script end\u0026#34;); // 同步代码 注意事项 JavaScript 是单线程语言，但浏览器是多线程的 事件循环确保了异步操作不会阻塞主线程 微任务优先级高于宏任务 过多的同步操作或长时间运行的任务会阻塞 UI 渲染 Node.js 的事件循环与浏览器有所不同 为什么需要区分宏任务和微任务？ 这是 JavaScript 在语言设计上对实时性和效率的权衡：\n当宏任务执行时间过长时，会影响后续任务的执行 某些任务需要在下一轮事件循环之前完成，以提高实时性 微任务提供了一种在当前宏任务结束之前执行异步代码的机制 有助于控制代码执行顺序，优化性能 ","permalink":"https://huing.github.io/posts/javascript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","summary":"什么是进程，什么是线程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。简单来说，进程就是程序的一次执行实例。当你运行一个程序时，操作系统会为该程序创建一个进程。\n线程（Thread）是操作系统能够进行运算调度的最小单位，被包含在进程之中。一个进程可以包含多个线程。线程是程序执行流的最小单元，负责实际的计算工作。\n进程特点 独立的内存空间：每个进程都有自己独立的内存空间，互不干扰 拥有系统资源：进程拥有独立的系统资源，如文件句柄、网络连接等 相互独立：一个进程的崩溃通常不会影响其他进程 通信成本高：进程间通信(IPC)需要特殊的机制，如管道、消息队列等 创建和销毁开销大：需要分配和回收系统资源 线程特点 共享所属进程的内存空间：同一进程内的线程共享进程的内存空间 共享进程资源：共享进程的代码段、数据段等资源 执行开销小：创建和切换线程的成本远低于进程 通信方便：线程间可以直接读写进程的共享数据 相互影响：一个线程崩溃可能导致整个进程崩溃 进程与线程的关系 一个进程至少包含一个线程（主线程） 线程是进程中的实际执行单位 同一进程中的线程共享进程的资源 进程是资源分配的最小单位，线程是 CPU 调度的最小单位 事件循环 Event Loop 事件循环是 JavaScript 实现异步的核心机制。JavaScript 是单线程的语言，但通过事件循环实现了非阻塞的异步执行模型。\n核心概念 调用栈(Call Stack)\nJavaScript 代码执行的地方 函数调用形成栈帧 遵循后进先出(LIFO)原则 同一时间只能执行一个任务 堆(Heap)\n存储对象的内存区域 代码运行时分配的内存空间 由垃圾回收器管理 任务队列(Task Queue)\n存储待执行的回调函数 遵循先进先出(FIFO)原则 分为宏任务队列和微任务队列 事件循环的执行流程 执行同步代码，同步代码进入调用栈立即执行 遇到异步任务时，将其交给相应的 Web API 处理 Web API 处理完成后，将回调函数放入任务队列 当调用栈为空时，事件循环检查任务队列 将任务队列中的任务按顺序放入调用栈执行 重复以上步骤 任务类型 宏任务(MacroTask) 宏任务是由标准 JavaScript 引擎机制提供的任务，它们会被放入消息队列中等待主线程执行。当一个宏任务执行时：\nV8 引擎会建立新的执行栈来存储任务 执行不同的函数调用时栈会随之变化 当该宏任务执行结束时，会清空当前的栈 常见的宏任务包括：\nscript(整体代码): JavaScript 脚本的初始化执行属于第一个宏任务 事件回调 setTimeout/setInterval 回调 setImmediate(Node.","title":"事件循环"},{"content":"什么是虚拟 dom Virtual DOM 则是一种由 Javascript 类库基于浏览器 API 实现的概念\n虚拟 dom 就是用 js 对象来描述 dom 结构。\ndiff 算法 仅右移 const oldVdom = { type: \u0026#39;div\u0026#39;, props: { children: [] } children: [ { type: \u0026#39;p\u0026#39;, props: {} children: [] }, { type: \u0026#39;p\u0026#39;, props: {} } ] } const newVdom = { type: \u0026#39;div\u0026#39;, props: {} children: [ { type: \u0026#39;p\u0026#39;, props: {} }, { type: \u0026#39;p\u0026#39;, props: {} } ] } function diff(oldVdom, newVdom) { if (oldVdom.type === newVdom.type) { for (let i = 0; i \u0026lt; oldVdom.children.length; i++) { diff(oldVdom.children[i], newVdom.children[i]) if (oldVdom.children[i] !== newVdom.children[i]) { oldVdom.children[i] = newVdom.children[i] } } } } ","permalink":"https://huing.github.io/posts/react/react%E7%9A%84diff%E7%AE%97%E6%B3%95/","summary":"什么是虚拟 dom Virtual DOM 则是一种由 Javascript 类库基于浏览器 API 实现的概念\n虚拟 dom 就是用 js 对象来描述 dom 结构。\ndiff 算法 仅右移 const oldVdom = { type: \u0026#39;div\u0026#39;, props: { children: [] } children: [ { type: \u0026#39;p\u0026#39;, props: {} children: [] }, { type: \u0026#39;p\u0026#39;, props: {} } ] } const newVdom = { type: \u0026#39;div\u0026#39;, props: {} children: [ { type: \u0026#39;p\u0026#39;, props: {} }, { type: \u0026#39;p\u0026#39;, props: {} } ] } function diff(oldVdom, newVdom) { if (oldVdom.","title":"React的diff算法"},{"content":"vue-router 路由守卫 路由原理 beforeEnter(to, from, next) {} vue 响应式数据 原理 数组更新\nvuex 和 pinia 响应式数据原理区别 vuex 和 pinia 区别是什么\n架构设计 Vuex 基于模块化设计，使用 mutations、actions、modules 等概念 Pinia 采用更简单的 Store 设计，没有 mutations，直接使用 actions 进行状态修改 Pinia 的 Store 可以直接定义，不需要像 Vuex 那样创建复杂的模块树 TypeScript 支持 Pinia 是用 TypeScript 编写的，提供了更好的类型推导和类型安全 Vuex 对 TypeScript 的支持相对较弱，需要额外的类型声明 开发体验 Pinia 支持多个 Store，可以相互独立 Pinia 的 devtools 调试体验更好 Pinia 代码更简洁，不需要写 mutations Pinia 支持自动代码分割（code splitting） 性能 Pinia 体积更小，打包后约 1KB Pinia 没有嵌套模块，扁平化设计使得性能更好 Vue 版本支持 Pinia 同时支持 Vue 2 和 Vue 3 Vuex 4 只支持 Vue 3，Vuex 3 只支持 Vue 2 // Vuex 示例 const store = new Vuex.Store({ state: { count: 0, }, mutations: { increment(state) { state.count++; }, }, actions: { incrementAsync({ commit }) { setTimeout(() =\u0026gt; { commit(\u0026#34;increment\u0026#34;); }, 1000); }, }, }); // Pinia 示例 export const useCounterStore = defineStore(\u0026#34;counter\u0026#34;, { state: () =\u0026gt; ({ count: 0 }), actions: { increment() { this.count++; }, async incrementAsync() { setTimeout(() =\u0026gt; { this.count++; }, 1000); }, }, }); 总的来说，Pinia 是更现代化的状态管理方案，提供了更好的开发体验和类型支持。Vue 官方也推荐使用 Pinia 作为新项目的状态管理方案\nSuspense \u0026lt;Suspense\u0026gt; 是一个内置组件，用来在组件树中协调对异步依赖的处理\n","permalink":"https://huing.github.io/posts/vue/","summary":"vue-router 路由守卫 路由原理 beforeEnter(to, from, next) {} vue 响应式数据 原理 数组更新\nvuex 和 pinia 响应式数据原理区别 vuex 和 pinia 区别是什么\n架构设计 Vuex 基于模块化设计，使用 mutations、actions、modules 等概念 Pinia 采用更简单的 Store 设计，没有 mutations，直接使用 actions 进行状态修改 Pinia 的 Store 可以直接定义，不需要像 Vuex 那样创建复杂的模块树 TypeScript 支持 Pinia 是用 TypeScript 编写的，提供了更好的类型推导和类型安全 Vuex 对 TypeScript 的支持相对较弱，需要额外的类型声明 开发体验 Pinia 支持多个 Store，可以相互独立 Pinia 的 devtools 调试体验更好 Pinia 代码更简洁，不需要写 mutations Pinia 支持自动代码分割（code splitting） 性能 Pinia 体积更小，打包后约 1KB Pinia 没有嵌套模块，扁平化设计使得性能更好 Vue 版本支持 Pinia 同时支持 Vue 2 和 Vue 3 Vuex 4 只支持 Vue 3，Vuex 3 只支持 Vue 2 // Vuex 示例 const store = new Vuex.","title":"Vue"},{"content":"Queue 先进先出 class Queue { constructor() { this.items = []; // 用于存储队列元素的数组 } // 入队方法 - 在队列尾部添加元素 enqueue(element) { this.items.push(element); } // 出队方法 - 移除并返回队列头部的元素 dequeue() { if (this.isEmpty()) { return \u0026#34;队列为空\u0026#34;; } return this.items.shift(); } // 查看队列头部的元素 peek() { if (this.isEmpty()) { return \u0026#34;队列为空\u0026#34;; } return this.items[0]; } // 检查队列是否为空 isEmpty() { return this.items.length === 0; } // 返回队列的大小 size() { return this.items.length; } // 清空队列 clear() { this.items = []; } // 打印队列内容 print() { console.log(this.items.toString()); } } Stack 先进后出 class Stack { constructor() { this.items = []; } // 入栈 push(element) { this.items.push(element); } // 出栈 pop() { if (this.isEmpty()) { return \u0026#34;栈为空\u0026#34;; } return this.items.pop(); } // 查看栈顶元素 peek() { if (this.isEmpty()) { return \u0026#34;栈为空\u0026#34;; } return this.items[this.items.length - 1]; } // 检查栈是否为空 isEmpty() { return this.items.length === 0; } // 返回栈的大小 size() { return this.items.length; } // 清空栈 clear() { this.items = []; } // 打印栈内容 print() { console.log(this.items.toString()); } } 使用队列实现栈的出栈入栈 class StackUsingQueues { constructor() { this.queue1 = []; // 主队列 this.queue2 = []; // 辅助队列 } // 入栈操作 push(x) { // 先将新元素加入空队列2 this.queue2.push(x); // 将队列1中的所有元素依次出队并加入队列2 while (this.queue1.length \u0026gt; 0) { this.queue2.push(this.queue1.shift()); } console.log(this.queue1, this.queue2); console.log(\u0026#34;---------\u0026#34;); // 交换队列1和队列2的引用 [this.queue1, this.queue2] = [this.queue2, this.queue1]; console.log(this.queue1, this.queue2); // // 先将新元素入队 // this.queue1.push(x) // // 将前面的元素依次出队并重新入队，使新元素位于队列前端 // for (let i = 0; i \u0026lt; this.queue1.length - 1; i++) { // this.queue1.push(this.queue1.shift()) // } } // 出栈操作 pop() { if (this.empty()) { return \u0026#34;栈为空\u0026#34;; } return this.queue1.shift(); } // 查看栈顶元素 top() { if (this.empty()) { return \u0026#34;栈为空\u0026#34;; } return this.queue1[0]; } // 检查栈是否为空 empty() { return this.queue1.length === 0; } } ","permalink":"https://huing.github.io/posts/javascript/stack/","summary":"Queue 先进先出 class Queue { constructor() { this.items = []; // 用于存储队列元素的数组 } // 入队方法 - 在队列尾部添加元素 enqueue(element) { this.items.push(element); } // 出队方法 - 移除并返回队列头部的元素 dequeue() { if (this.isEmpty()) { return \u0026#34;队列为空\u0026#34;; } return this.items.shift(); } // 查看队列头部的元素 peek() { if (this.isEmpty()) { return \u0026#34;队列为空\u0026#34;; } return this.items[0]; } // 检查队列是否为空 isEmpty() { return this.items.length === 0; } // 返回队列的大小 size() { return this.items.length; } // 清空队列 clear() { this.items = []; } // 打印队列内容 print() { console.","title":"Stack"},{"content":"Canvas 基础概念 Canvas 是 HTML5 提供的用于在网页上绘制图形的元素。它可以用于绘制图表、制作图片合成或者实现基础的动画效果。\n基本用法 创建 Canvas 元素 获取绘图上下文(Context) 使用 Canvas API 进行绘制 常见绘图操作 绘制形状(矩形、圆形、路径等) 添加颜色和样式 绘制文本 图片操作 变换(平移、旋转、缩放) Canvas API 实例 1. 基础图形绘制 // 获取Canvas上下文 const canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); const ctx = canvas.getContext(\u0026#34;2d\u0026#34;); // 绘制矩形 ctx.fillStyle = \u0026#34;red\u0026#34;; // 设置填充颜色 ctx.fillRect(10, 10, 100, 50); // x, y, width, height // 绘制圆形 ctx.beginPath(); ctx.arc(100, 100, 50, 0, Math.PI * 2); // x, y, 半径, 起始角度, 结束角度 ctx.fillStyle = \u0026#34;blue\u0026#34;; ctx.fill(); 2. 绘制路径 // 绘制三角形 ctx.beginPath(); ctx.moveTo(50, 50); // 起点 ctx.lineTo(150, 50); // 第二点 ctx.lineTo(100, 150); // 第三点 ctx.closePath(); // 闭合路径 ctx.fillStyle = \u0026#34;green\u0026#34;; ctx.fill(); 3. 文本绘制 // 设置文本样式 ctx.font = \u0026#34;24px Arial\u0026#34;; ctx.fillStyle = \u0026#34;black\u0026#34;; ctx.textAlign = \u0026#34;center\u0026#34;; ctx.fillText(\u0026#34;Hello Canvas!\u0026#34;, 150, 100); // 带描边的文本 ctx.strokeStyle = \u0026#34;red\u0026#34;; ctx.lineWidth = 2; ctx.strokeText(\u0026#34;Outlined Text\u0026#34;, 150, 150); 4. 图片处理 const img = new Image(); img.src = \u0026#34;path/to/image.jpg\u0026#34;; img.onload = () =\u0026gt; { // 绘制图片 ctx.drawImage(img, 0, 0); // 缩放绘制 ctx.drawImage(img, 0, 0, 200, 100); // 裁剪绘制 ctx.drawImage( img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight ); }; 5. 动画效果 let x = 0; function animate() { // 清除画布 ctx.clearRect(0, 0, canvas.width, canvas.height); // 绘制移动的矩形 ctx.fillStyle = \u0026#34;purple\u0026#34;; ctx.fillRect(x, 50, 50, 50); // 更新位置 x = (x + 2) % canvas.width; // 请求下一帧 requestAnimationFrame(animate); } animate(); 6. 渐变效果 // 线性渐变 const gradient = ctx.createLinearGradient(0, 0, 200, 0); gradient.addColorStop(0, \u0026#34;red\u0026#34;); gradient.addColorStop(0.5, \u0026#34;green\u0026#34;); gradient.addColorStop(1, \u0026#34;blue\u0026#34;); ctx.fillStyle = gradient; ctx.fillRect(0, 0, 200, 100); // 径向渐变 const radialGradient = ctx.createRadialGradient(100, 100, 0, 100, 100, 50); radialGradient.addColorStop(0, \u0026#34;white\u0026#34;); radialGradient.addColorStop(1, \u0026#34;black\u0026#34;); ctx.fillStyle = radialGradient; ctx.fillRect(50, 50, 100, 100); 7. 变换操作 // 保存当前状态 ctx.save(); // 平移 ctx.translate(100, 100); // 旋转 (弧度) ctx.rotate(Math.PI / 4); // 缩放 ctx.scale(2, 2); // 绘制 ctx.fillStyle = \u0026#34;orange\u0026#34;; ctx.fillRect(-25, -25, 50, 50); // 恢复之前的状态 ctx.restore(); 完整示例 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Canvas Demo\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; canvas { border: 1px solid #000; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script\u0026gt; const canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); const ctx = canvas.getContext(\u0026#34;2d\u0026#34;); // 这里可以放入上述任意示例代码 // 示例: 绘制一个简单的场景 // 背景 ctx.fillStyle = \u0026#34;#87CEEB\u0026#34;; ctx.fillRect(0, 0, 400, 300); // 太阳 ctx.beginPath(); ctx.arc(350, 50, 30, 0, Math.PI * 2); ctx.fillStyle = \u0026#34;yellow\u0026#34;; ctx.fill(); // 草地 ctx.fillStyle = \u0026#34;#90EE90\u0026#34;; ctx.fillRect(0, 200, 400, 100); // 房子 ctx.fillStyle = \u0026#34;#8B4513\u0026#34;; ctx.fillRect(100, 150, 80, 80); // 屋顶 ctx.beginPath(); ctx.moveTo(90, 150); ctx.lineTo(140, 100); ctx.lineTo(190, 150); ctx.fillStyle = \u0026#34;#A52A2A\u0026#34;; ctx.fill(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; WebGL 进阶 WebGL 是基于 OpenGL ES 的 3D 绘图标准,能在 Canvas 中实现硬件加速的 3D 渲染。\nWebGL 特点 底层图形 API 支持 3D 渲染 硬件加速 着色器编程 实际应用案例 飞书表格的实现原理 在线表格应用(如飞书表格)使用 Canvas 的优势:\n高性能渲染大量单元格 自定义绘制和样式 优化滚动和缩放 内存管理 性能优化 提升 Canvas 性能的关键点 批量绘制操作 使用 requestAnimationFrame 离屏渲染(Off-screen Canvas) 图层分离 避免不必要的状态改变 合理使用缓存 性能监控 FPS 监测 内存占用 渲染时间 Canvas 与 WebGL 结合使用 Canvas 和 WebGL 可以在同一个页面中协同工作，下面是一个结合示例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Canvas + WebGL Demo\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .canvas-container { display: flex; gap: 20px; } canvas { border: 1px solid #000; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;canvas-container\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;canvas2D\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;canvas id=\u0026#34;canvasWebGL\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 2D Canvas 部分 const canvas2D = document.getElementById(\u0026#34;canvas2D\u0026#34;); const ctx2D = canvas2D.getContext(\u0026#34;2d\u0026#34;); // 绘制2D动画 function draw2D(time) { ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height); // 绘制旋转的方块 ctx2D.save(); ctx2D.translate(200, 150); ctx2D.rotate(time * 0.001); ctx2D.fillStyle = \u0026#34;blue\u0026#34;; ctx2D.fillRect(-50, -50, 100, 100); ctx2D.restore(); requestAnimationFrame(draw2D); } // WebGL 部分 const canvasGL = document.getElementById(\u0026#34;canvasWebGL\u0026#34;); const gl = canvasGL.getContext(\u0026#34;webgl\u0026#34;); // 顶点着色器程序 const vertexShaderSource = ` attribute vec4 aVertexPosition; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; void main() { gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; } `; // 片段着色器程序 const fragmentShaderSource = ` precision mediump float; void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } `; // 创建着色器程序 function createShader(gl, type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); return shader; } // 初始化着色器程序 const vertexShader = createShader( gl, gl.VERTEX_SHADER, vertexShaderSource ); const fragmentShader = createShader( gl, gl.FRAGMENT_SHADER, fragmentShaderSource ); const shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); // 创建缓冲区 const positions = [ -0.5, 0.5, 0.0, // 左上 0.5, 0.5, 0.0, // 右上 0.5, -0.5, 0.0, // 右下 -0.5, -0.5, 0.0, // 左下 ]; const positionBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.bufferData( gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW ); // 渲染WebGL场景 function drawWebGL(time) { gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.useProgram(shaderProgram); const vertexPosition = gl.getAttribLocation( shaderProgram, \u0026#34;aVertexPosition\u0026#34; ); gl.vertexAttribPointer(vertexPosition, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(vertexPosition); gl.drawArrays(gl.TRIANGLE_FAN, 0, 4); requestAnimationFrame(drawWebGL); } // 启动动画 draw2D(0); drawWebGL(0); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个示例展示了：\n2D Canvas 部分 创建一个旋转的蓝色方块 使用基础的 2D 变换和动画 WebGL 部分 创建一个红色的矩形 使用基础的着色器程序 实现 WebGL 基本渲染流程 结合要点 使用两个独立的 canvas 元素 分别初始化 2D 和 WebGL 上下文 独立的动画循环 同步渲染 使用场景 Canvas 和 WebGL 结合使用的常见场景：\n混合渲染 2D UI 元素使用 Canvas 3D 场景使用 WebGL 提高特定场景的性能 性能优化 简单 2D 图形用 Canvas 复杂 3D 效果用 WebGL 根据设备性能动态切换 特效叠加 WebGL 渲染主场景 Canvas 绘制 UI 覆盖层 实现复杂的视觉效果 注意事项 上下文切换 避免频繁切换上下文 合理规划渲染层级 性能考虑 注意内存使用 优化渲染循环 考虑设备兼容性 调试方法 使用浏览器开发工具 监控 FPS 和内存 分析性能瓶颈 ","permalink":"https://huing.github.io/posts/html/canvas/","summary":"Canvas 基础概念 Canvas 是 HTML5 提供的用于在网页上绘制图形的元素。它可以用于绘制图表、制作图片合成或者实现基础的动画效果。\n基本用法 创建 Canvas 元素 获取绘图上下文(Context) 使用 Canvas API 进行绘制 常见绘图操作 绘制形状(矩形、圆形、路径等) 添加颜色和样式 绘制文本 图片操作 变换(平移、旋转、缩放) Canvas API 实例 1. 基础图形绘制 // 获取Canvas上下文 const canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); const ctx = canvas.getContext(\u0026#34;2d\u0026#34;); // 绘制矩形 ctx.fillStyle = \u0026#34;red\u0026#34;; // 设置填充颜色 ctx.fillRect(10, 10, 100, 50); // x, y, width, height // 绘制圆形 ctx.beginPath(); ctx.arc(100, 100, 50, 0, Math.PI * 2); // x, y, 半径, 起始角度, 结束角度 ctx.fillStyle = \u0026#34;blue\u0026#34;; ctx.","title":"Canvas"},{"content":"实现一个 EventBus 发布/订阅设计模式 EventBus 是 一个事件总线，它允许多个组件之间进行通信。 在 javascript 中，我们可以使用一个类来表示 EventBus。\nclass EventBus { constructor() { this.events = {}; } on(eventName, callback) { if (!this.events[eventName]) { this.events[eventName] = []; } this.events[eventName].push(callback); } off(eventName, callback) { if (!this.events[eventName]) { return; } if (callback) { this.events[eventName] = this.events[eventName].filter( (cb) =\u0026gt; cb !== callback ); } else { delete this.events[eventName]; } } emit(eventName, ...args) { if (!this.events[eventName]) { return; } this.events[eventName].forEach((callback) =\u0026gt; { callback(...args); }); } once(eventName, callback) { const onceCallback = (...args) =\u0026gt; { callback(...args); this.off(eventName, onceCallback); }; this.on(eventName, onceCallback); } } ","permalink":"https://huing.github.io/posts/javascript/eventbus/","summary":"实现一个 EventBus 发布/订阅设计模式 EventBus 是 一个事件总线，它允许多个组件之间进行通信。 在 javascript 中，我们可以使用一个类来表示 EventBus。\nclass EventBus { constructor() { this.events = {}; } on(eventName, callback) { if (!this.events[eventName]) { this.events[eventName] = []; } this.events[eventName].push(callback); } off(eventName, callback) { if (!this.events[eventName]) { return; } if (callback) { this.events[eventName] = this.events[eventName].filter( (cb) =\u0026gt; cb !== callback ); } else { delete this.events[eventName]; } } emit(eventName, ...args) { if (!this.events[eventName]) { return; } this.events[eventName].forEach((callback) =\u0026gt; { callback(...args); }); } once(eventName, callback) { const onceCallback = (.","title":"EventBus"},{"content":"异常值（Outliers）\n噪声（Noise）\nMCP 设置 node=20\nnvm use 20 npx -y 把 npm 源设为 npm\nnrm ls nrm use npm export GITHUB_PERSONAL_ACCESS_TOKEN=\u0026#34;\u0026#34; echo \u0026#39;{\u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;:\u0026#34;tools/call\u0026#34;, \u0026#34;params\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;search_repositories\u0026#34;, \u0026#34;arguments\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;user:huing\u0026#34; }}, \u0026#34;id\u0026#34;: 123}\u0026#39; | npx -y @modelcontextprotocol/server-github ","permalink":"https://huing.github.io/posts/llm/ai/","summary":"异常值（Outliers）\n噪声（Noise）\nMCP 设置 node=20\nnvm use 20 npx -y 把 npm 源设为 npm\nnrm ls nrm use npm export GITHUB_PERSONAL_ACCESS_TOKEN=\u0026#34;\u0026#34; echo \u0026#39;{\u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;:\u0026#34;tools/call\u0026#34;, \u0026#34;params\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;search_repositories\u0026#34;, \u0026#34;arguments\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;user:huing\u0026#34; }}, \u0026#34;id\u0026#34;: 123}\u0026#39; | npx -y @modelcontextprotocol/server-github ","title":"AI"},{"content":"基础类型 布尔值（boolean） 可选类型 true/false\nlet booleanExample: boolean = false; 数字（number） 可选类型 number\nlet numberExample: number = 6; 字符串（string） 可选类型 string\nlet stringExample: string = \u0026#34;Demo\u0026#34;; let stringTemplate: string = `template${Demo}`; void void 表示没有任何类型\nfunction sayHi(): void { console.log(\u0026#34;Hi!\u0026#34;); } let nothing: void = undefined; let unusable: void = null; // 不能将类型“null”分配给类型“void” let num: void = 1; // Error: 不能将类型“number”分配给类型“void” null 和 undefined let u: undefined = undefined; let n: null = null; 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 然而，当你指定了 strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。 许在某处你想传入一个 string 或 null 或 undefined，可以使用联合类型 string | null | undefined\n特殊类型 any 任意类型\nlet demand: any; unknown unknown 类型和 any 都可以表示任何类型。区别是 any 类型的变量是可以进行任意进行赋值、实例化、函数执行等操作，但是 unknown 只允许赋值，不允许实例化、函数执行等操作\nlet demandOne: any; let demandTwo: unknown; demandOne = \u0026#34;Hello, Tuture\u0026#34;; // 可以的 demandTwo = \u0026#34;Hello, Ant Design\u0026#34;; // 可以的 demandOne.foo.bar(); // 可以的 demandTwo.foo.bar(); // 报错 never never 表示永远不存在的值的类型，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。除了 never 本身以外，其他任何类型不能赋值给 never。\n// 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\u0026#34;Something failed\u0026#34;); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) {} } 数组 const values: string[] = [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]; const values: Array\u0026lt;string\u0026gt; = [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]; // 多类型数组 const values: (string | number)[] = [\u0026#34;Apple\u0026#34;, 2, \u0026#34;Orange\u0026#34;, 3, 4, \u0026#34;Banana\u0026#34;]; values = [\u0026#34;Apple\u0026#34;, 2, true]; // 不能将类型“boolean”分配给类型“string | number” // 数组对象 const arr: { name: string; age: number }[] = [ { name: \u0026#34;Alice\u0026#34;, age: 27 }, { name: \u0026#34;Bob\u0026#34;, age: 28 }, { name: \u0026#34;Carl\u0026#34;, age: 29 }, ]; // 接口形式声明数组对象 interface Person { name: string; age: number; } const arr2: Person[] = [ { name: \u0026#34;Alice\u0026#34;, age: 27 }, { name: \u0026#34;Bob\u0026#34;, age: 28 }, { name: \u0026#34;Carl\u0026#34;, age: 29 }, ]; interface Array { [index: number]: any; // or 其他item类型 } 元组类型 元组允许定义数组的每一项的类型\nconst values: [string, number] = [\u0026#34;a\u0026#34;, 2]; 接口 它相当于类型中的 JS 对象，用于对函数、类等进行结构类型检查，所谓的结构类型检查，就是两个类型的结构一样，那么它们的类型就是兼容的，这在计算机科学的世界里也被称为 “鸭子类型”。\n当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子\ninterface PostDataDTO { title: string; id: number; date: string; contentHtml: string; } const postData: PostDataDTO; 可选属性 ? interface PostDataDTO { title: string; id: number; date?: string; contentHtml: string; } 只读属性 readonly interface PostDataDTO { title: string; readonly id: number; date?: string; contentHtml: string; } const postData: PostDataDTO = { id: 1, date: \u0026#34;2022-11-09\u0026#34;, title: \u0026#34;Duck\u0026#34;, contentHtml: \u0026#34;Duck Typing\u0026#34;, }; postData.date = \u0026#34;2022-11-10\u0026#34;; postData.id = 2; // 无法分配到 \u0026#34;id\u0026#34; ，因为它是只读属性。 多余属性 动态增加属性\ninterface PostDataDTO { title: string; readonly id: number; date?: string; contentHtml: string; [propName: string]: any; } const postData: PostDataDTO = { id: 1, date: \u0026#34;2022-11-09\u0026#34;, title: \u0026#34;Duck\u0026#34;, contentHtml: \u0026#34;Duck Typing\u0026#34;, }; postData.isDeleted = 1; // 不会报错 继承接口 interface Shape { color: string; } interface PenStroke { penWidth: number; } // 一个接口可以继承多个接口 interface Square extends Shape, PenStroke { sideLength: number; } 接口合并 接口是开放式的，它允许你使用接口来模仿 js 的可扩展性。但是合并的属性需要保持类型一致，函数会重载\ninterface Point { x: number; y: number; hasPoint(id: number): number; } interface Point { x: string; // 后续属性声明必须属于同一类型。属性“x”的类型必须为“number”，但此处却为类型“string” z: number; hasPoint(id: string): string; } class Crazy implements Point { x: number = 1; y: number = 1; z: number = 1; // https://stackoverflow.com/questions/52602528/typescript-interface-method-overload-doesnt-work hasPoint(id: string): string; hasPoint(id: number): number; hasPoint(id: unknown): unknown { if (typeof id === \u0026#34;string\u0026#34;) { return \u0026#34;1\u0026#34;; } if (typeof id === \u0026#34;number\u0026#34;) { return 1; } } } const ponit: Crazy = new Crazy(); ponit.x; ponit.y; ponit.z; ponit.hasPoint(1); ponit.hasPoint(\u0026#34;1\u0026#34;); 枚举 基本语法 enum Continents { North_America, South_America, } // usage const region = Continents.Africa; 数字枚举 enum Weekend { Friday, Saturday, Sunday, } 计算枚举 enum Weekend { Friday = 1, Saturday = getDate(\u0026#34;TGIF\u0026#34;), Sunday = Saturday * 40, Thursday = 4, } function getDate(day: string): number { if (day === \u0026#34;TGIF\u0026#34;) { return 3; } } Weekend.Saturday; // returns 3 Weekend.Sunday; // returns 120 字符串枚举 enum Weekend { Friday = \u0026#34;FRIDAY\u0026#34;, Saturday = \u0026#34;SATURDAY\u0026#34;, Sunday = \u0026#34;SUNDAY\u0026#34;, } const value = someString as Weekend; if (value === Weekend.Friday || value === Weekend.Sunday) { console.log(\u0026#34;You choose a weekend\u0026#34;); console.log(value); } 异构枚举 enum Weekend { Friday = \u0026#34;FRIDAY\u0026#34;, Saturday = 1, Sunday = 2, } 反向映射 enum Weekend { Friday = 1, Saturday, Sunday } // console.log(Weekend); { \u0026#39;1\u0026#39;: \u0026#39;Friday\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;Saturday\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;Sunday\u0026#39;, Friday: 1, Saturday: 2, Sunday: 3 } Weekend[1] // Friday Weekend[\u0026#39;Friday\u0026#39;] // 1 函数 注解函数 function greet(person: string): string { return `Hello, ${person}!`; } 变量类型 const add: (x: number, y: number) =\u0026gt; number = function (x, y) { return x + y; }; const add = (x: number, y: number): number =\u0026gt; { return x + y; }; 可选参数 function add(x: number, y?: number): number { return x + (y || 0); } 默认参数 function add(x: number, y: number = 10): number { return x + y; } add(1); 函数重载 用联合类型声明 function greet(person: string | string[]): string | string[] { if (typeof person === \u0026#34;string\u0026#34;) { return `Hello, ${person}!`; } else if (Array.isArray(person)) { return person.map((name) =\u0026gt; `Hello, ${name}!`); } throw new Error(\u0026#34;Unable to greet\u0026#34;); } greet(\u0026#34;World\u0026#34;); // \u0026#39;Hello, World!\u0026#39; greet([\u0026#34;Jane\u0026#34;, \u0026#34;Joe\u0026#34;]); // [\u0026#39;Hello, Jane!\u0026#39;, \u0026#39;Hello, Joe!\u0026#39;] 此种方法缺点是函数提示不明显，输入字符串时明确返回值是 string 类型，但编译器依然提示 string | stirng[]\n函数重载 Overloads // Overload signatures function greet(person: string): string; function greet(persons: string[]): string[]; // Implementation signature function greet(person: unknown): unknown { if (typeof person === \u0026#34;string\u0026#34;) { return `Hello, ${person}!`; } else if (Array.isArray(person)) { return person.map((name) =\u0026gt; `Hello, ${name}!`); } throw new Error(\u0026#34;Unable to greet\u0026#34;); } greet(\u0026#34;World\u0026#34;); // \u0026#39;Hello, World!\u0026#39; greet([\u0026#34;Jane\u0026#34;, \u0026#34;Joe\u0026#34;]); // [\u0026#39;Hello, Jane!\u0026#39;, \u0026#39;Hello, Joe!\u0026#39;] const someValue: unknown = \u0026#34;Unknown\u0026#34;; greet(someValue); // 报错 此时调用函数能看到明确的语法提示\n变量声明 unknown 依然会报错，因为只有重载签名是可调用的，虽然实现签名实现了函数行为，但它不能直接调用。\n类型别名声明函数重载 interface Data { postalCodes: string[]; country: string; } const data: Data = { postalCodes: [\u0026#34;123\u0026#34;, \u0026#34;422\u0026#34;], country: \u0026#34;PL\u0026#34;, }; type GetData = { (data: Data, key: \u0026#34;postalCodes\u0026#34;): string[]; (data: Data, key: \u0026#34;country\u0026#34;): string; }; const getData: GetData = (data, key): any =\u0026gt; { return data[key]; }; const postalCodesRetrieved: string[] = getData(data, \u0026#34;postalCodes\u0026#34;); const counryRetrieved: string = getData(data, \u0026#34;country\u0026#34;); 方法重载 class Greeter { message: string; constructor(message: string) { this.message = message; } // Overload signatures greet(person: string): string; greet(persons: string[]): string[]; // Implementation signature greet(person: unknown): unknown { if (typeof person === \u0026#34;string\u0026#34;) { return `${this.message}, ${person}!`; } else if (Array.isArray(person)) { return person.map((name) =\u0026gt; `${this.message}, ${name}!`); } throw new Error(\u0026#34;Unable to greet\u0026#34;); } } const hi = new Greeter(\u0026#34;Hi\u0026#34;); hi.greet(\u0026#34;Angela\u0026#34;); // \u0026#39;Hi, Angela!\u0026#39; hi.greet([\u0026#34;Pam\u0026#34;, \u0026#34;Jim\u0026#34;]); // [\u0026#39;Hi, Pam!\u0026#39;, \u0026#39;Hi, Jim!\u0026#39;] 交叉类型 \u0026amp; 交叉类型就是多个类型通过 \u0026amp; 类型运算符，合并成一个类型，这个类型包含了多个类型中的所有类型成员\ninterface A { name: string; age: number; } interface B { name: number; id: string; } type Union = A \u0026amp; B; const unionObj = {} as Union; unionObj.name = \u0026#34;xixi\u0026#34;; // name: never。 不能将类型“string”分配给类型“never” unionObj.id = \u0026#34;2\u0026#34;; // string unionObj.age = 20; // number 联合类型 | 联合类型是通过操作符 | 将多个类型进行联合，组成一个复合类型，当用这个复合类型注解一个变量的时候，这个变量可以取这个复合类型中的任意一个类型，但是最终只能取一个类型\ninterface A { name: string; age: number; } interface B { name: number; id: string; } type Union = A | B; const unionObj = {} as Union; unionObj.name = \u0026#34;xixi\u0026#34;; // string | number unionObj.id = \u0026#34;2\u0026#34;; // 类型“Union”上不存在属性“id”。类型“A”上不存在属性“id” unionObj.age = 20; // 类型“Union”上不存在属性“age”。类型“B”上不存在属性“age” 类型断言 \u0026lt;\u0026gt; interface Foo { bar: number; bas: string; } const foo = \u0026lt;Foo\u0026gt;{}; foo.bar = 1; let defaultBar: any; let bar = \u0026lt;string\u0026gt;defaultBar; // 现在 bar 的类型是 \u0026#39;string\u0026#39; as 推荐用法 interface Foo { bar: number; bas: string; } const foo = {} as Foo; foo.bar = 123; 双重断言 function handler(event: Event) { const element = event as HTMLElement; // Error: \u0026#39;Event\u0026#39; 和 \u0026#39;HTMLElement\u0026#39; 中的任何一个都不能赋值给另外一个 } function handler(event: Event) { const element = event as any as HTMLElement; // ok } 字面量类型 字面量是 TS 类型系统里面最小的类型，就像 JS 里面的数字 1，它不可能再拆成更小的部分了\n数字字面量 let age: 20; age = 30; // 不能将类型“30”分配给类型“20” 字符串字面量 let age: \u0026#34;20\u0026#34;; age = \u0026#34;30\u0026#34;; // 不能将类型“\u0026#34;30\u0026#34;”分配给类型“\u0026#34;20\u0026#34;”。 字面量用途\n实现枚举 联合类型+字面量类型 osType: \u0026#34;Linux\u0026#34; | \u0026#34;Mac\u0026#34; | \u0026#34;Windows\u0026#34;; 实现类型守卫 类型守卫 TS 在遇到一些些条件语句时，会在语句的块级作用域内「收紧」变量的类型，这种类型推断的行为称作类型守卫 (Type Guard)\n字面量相等判断 ==, !=, ===, !== type Foo = \u0026#34;foo\u0026#34; | \u0026#34;bar\u0026#34; | \u0026#34;unknown\u0026#34;; function test(input: Foo) { if (input != \u0026#34;unknown\u0026#34;) { // 这里 input 的类型「收紧」为 \u0026#39;foo\u0026#39; | \u0026#39;bar\u0026#39; } else { // 这里 input 的类型「收紧」为 \u0026#39;unknown\u0026#39; } } instanceof class Foo {} class Bar {} function test(input: Foo | Bar) { if (input instanceof Foo) { // 这里 input 的类型「收紧」为 Foo } else { // 这里 input 的类型「收紧」为 Bar } } in interface Foo { foo: string; } interface Bar { bar: string; } function test(input: Foo | Bar) { if (\u0026#34;foo\u0026#34; in input) { // 这里 input 的类型「收紧」为 Foo } else { // 这里 input 的类型「收紧」为 Bar } } typeof function StudentId(x: string | number) { if (typeof x == \u0026#34;string\u0026#34;) { console.log(\u0026#34;Student\u0026#34;); } if (typeof x === \u0026#34;number\u0026#34;) { console.log(\u0026#34;Id\u0026#34;); } } StudentId(`446`); // Student StudentId(446); // Id 自定义类型守卫 type Fish = { swim: () =\u0026gt; void }; type Bird = { fly: () =\u0026gt; void }; // | 联合类型 function getSmallPet(): Fish | Bird { return { swim: () =\u0026gt; {}, }; } // 类型谓词 is function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; } let pet = getSmallPet(); if (isFish(pet)) { pet.swim(); } else { pet.fly(); } 自定义类型守卫的意义是当我们需要明确返回值类型时可以用，如果去掉 pet is Fish ，isFish 的结果仅为 boolean，但我们需要明确的类型提示\n类型别名 语法\ntype Params = number; type Params = string | (() =\u0026gt; string); type Params2 = { name: string; age: number; }; type Params = { name: string; favorite: string; } \u0026amp; Params2; type Weekend = \u0026#34;Friday\u0026#34; | \u0026#34;Saturday\u0026#34; | \u0026#34;Sunday\u0026#34;; const week: Weekend; 类 类可以拿来进行类型注解 类的实例都可以用类名来注解 class Animal { name: string | undefined; static isAnimal(a: Animal): boolean { return a instanceof Animal; } constructor(name: string) { this.name = name; } move(distance: number) { console.log(`${this.name} moved ${distance}m.`); } } 访问限定符 public 公共的 class Animal { public name: string | undefined; public constructor(name: string) { this.name = name; } move(distance: number) { console.log(`${this.name} moved ${distance}m.`); } } const bird = new Animal(\u0026#34;Tuture\u0026#34;); bird.move(520); bird.name; protected 受保护的 class Animal { protected name: string | undefined; public constructor(name: string) { this.name = name; } move(distance: number) { console.log(`${this.name} moved ${distance}m.`); } } const bird = new Animal(\u0026#34;Tuture\u0026#34;); bird.move(520); bird.name; // 属性“name”受保护，只能在类“Animal”及其子类中访问 private 私有的 class Animal { private name: string | undefined; public constructor(name: string) { this.name = name; } move(distance: number) { console.log(`${this.name} moved ${distance}m.`); } } const bird = new Animal(\u0026#34;Tuture\u0026#34;); bird.move(520); // 编译器不会提示name属性 bird.name; //属性“name”为私有属性，只能在类“Animal”中访问。 readonly 只读属性 class Animal { public name: string = \u0026#34;Tuture\u0026#34;; readonly defautlDistance: number = 20; public constructor(name: string) { this.name = name; } move(distance?: number) { console.log(`${this.name} moved ${distance || this.defautlDistance}m.`); } } const bird = new Animal(\u0026#34;Tuture\u0026#34;); bird.move(); bird.defautlDistance = 30; // 无法分配到 \u0026#34;defautlDistance\u0026#34; ，因为它是只读属性 抽象类 // 抽象类 abstract class Animal { // 抽象方法 abstract makeSound(): void; move(): void { console.log(\u0026#34;Roaming the earth...\u0026#34;); } } const bird = new Animal(); // 无法创建抽象类的实例 抽象类只可以被继承，不可以被实例化\n继承抽象类必须实现抽象类中的抽象方法\nabstract class Animal { abstract makeSound(): void; move(): void { console.log(\u0026#34;Roaming the earth...\u0026#34;); } } class Bird extends Animal { makeSound(): void { console.log(\u0026#34;Tuture tuture tuture.\u0026#34;); } } 类与接口 类实现接口 // 报警器接口 interface Alarm { alert(): void; } // 灯开关接口 interface Light { lightOn(): void; lightOff(): void; } // 一个类可以实现多个接口 class Car implements Alarm, Light { alert() { console.log(\u0026#34;Car alarm\u0026#34;); } lightOn() { console.log(\u0026#34;Car lighton\u0026#34;); } lightOff() { console.log(\u0026#34;Car lightoff\u0026#34;); } } 类必须实现接口中的所有属性和方法\ninterface Point { x: number; y: number; z: number; } // 类“MyPoint”错误实现接口“Point”。 // 类型 \u0026#34;MyPoint\u0026#34; 中缺少属性 \u0026#34;z\u0026#34;，但类型 \u0026#34;Point\u0026#34; 中需要该属性。 class MyPoint implements Point { // ERROR : missing member `z` x: number; y: number; } // 类型 \u0026#34;MyPoint\u0026#34; 中缺少属性 \u0026#34;z\u0026#34;，但类型 \u0026#34;Point\u0026#34; 中需要该属性 let foo: Point = new MyPoint(); 接口继承类 class Point { x: number | undefined; y: number | undefined; } interface Point3d extends Point { z: number; } 类作为接口使用 class TodoInputProps { value: string = \u0026#34;tuture\u0026#34;; onChange(value: string) { console.log(\u0026#34;Hello Tuture\u0026#34;); } } interface TodoInputState { content: string; user: string; date: string; } // React.Component\u0026lt;TodoInputProps, TodoInputState\u0026gt; 泛型用法 class TodoInput extends React.Component\u0026lt;TodoInputProps, TodoInputState\u0026gt; { // 用类注解变量 static defaultProps: TodoInputProps = new TodoInputProps(); // 类注解类 // const TodoInputPropsAlias: typeof TodoInputProps = TodoInputProps render() { return \u0026lt;div\u0026gt;Hello World\u0026lt;/div\u0026gt;; } } 泛型 基本语法 function createArray\u0026lt;T\u0026gt;(length: number, value: T): Array\u0026lt;T\u0026gt; { let result: T[] = []; for (let i = 0; i \u0026lt; length; i++) { result[i] = value; } return result; } // 编译器自动推断类型 createArray(10, true); // function createArray\u0026lt;boolean\u0026gt;(length: number, value: boolean): boolean[] createArray(10, 1); // function createArray\u0026lt;number\u0026gt;(length: number, value: number): number[] createArray(10, \u0026#34;1\u0026#34;); // function createArray\u0026lt;string\u0026gt;(length: number, value: string): string[] 箭头函数范型 const createArray = \u0026lt;T\u0026gt;(length: number, value: T): Array\u0026lt;T\u0026gt; =\u0026gt; { let result: T[] = []; for (let i = 0; i \u0026lt; length; i++) { result[i] = value; } return result; }; const deleteArray = \u0026lt;T extends { id: number }\u0026gt;(arr: T[], value: any): T[] =\u0026gt; { return arr.filter((val: T) =\u0026gt; val.id != value); }; 类泛型 // eg1: class Todo\u0026lt;T\u0026gt; { title: T[] | undefined; } let todo = new Todo\u0026lt;string\u0026gt;(); todo.title = [\u0026#34;第一篇\u0026#34;, \u0026#34;第二篇\u0026#34;]; // eg:2 创建一个泛型类 class Queue\u0026lt;T\u0026gt; { private data: T[] = []; push = (item: T) =\u0026gt; this.data.push(item); pop = (): T | undefined =\u0026gt; this.data.shift(); } const queue = new Queue\u0026lt;number\u0026gt;(); queue.push(0); queue.push(\u0026#34;1\u0026#34;); // Error：类型“string”的参数不能赋给类型“number”的参数。 接口泛型 interface Todo\u0026lt;T\u0026gt; { title: string; content: string; time: T; } const todo: Todo\u0026lt;string\u0026gt;; todo.time; // string 类型别名泛型 type Todo\u0026lt;T\u0026gt; = { title: string; content: string; time: T; }; const todo: Todo\u0026lt;string\u0026gt;; todo.time; 泛型约束 type Todo\u0026lt;T\u0026gt; = { title: string; content: string; time: T; }; type Author = { nickName: string; penName: string; }; // 用 Todo\u0026lt;string\u0026gt; \u0026amp; Author 约束 U function todoList\u0026lt;T, U extends Todo\u0026lt;string\u0026gt; \u0026amp; Author\u0026gt;( info: T[], profile: U ): T[] { info.length; profile.nickName; return info; } 注解构造函数 class Profile\u0026lt;T\u0026gt; { username!: string; nickName!: string; avatar!: string; age!: T; } class TutureProfile extends Profile\u0026lt;string\u0026gt; { github!: string; remote!: string[]; } interface ConstructorFunction\u0026lt;C\u0026gt; { new (): C; } function createInstance\u0026lt;A extends Profile\u0026lt;string\u0026gt;\u0026gt;(B: ConstructorFunction\u0026lt;A\u0026gt;) { return new B(); } // function createInstance\u0026lt;TutureProfile\u0026gt;(B: ConstructorFunction\u0026lt;TutureProfile\u0026gt;): TutureProfile const myTutureProfile = createInstance(TutureProfile); extends 条件类型 类型匹配\ntype IsNumber\u0026lt;T, U\u0026gt; = T extends U ? number : string; type Num = IsNumber\u0026lt;1, number\u0026gt;; // number; type Str = IsNumber\u0026lt;\u0026#34;1\u0026#34;, number\u0026gt;; // string; 联合类型 A 的所有子类型，在联合类型 B 中存在，则条件满足\ntype AB\u0026lt;T, U\u0026gt; = T extends U ? \u0026#34;a\u0026#34; : \u0026#34;b\u0026#34;; type A = AB\u0026lt;\u0026#34;x\u0026#34;, \u0026#34;x\u0026#34; | \u0026#34;y\u0026#34;\u0026gt;; // 确定条件，结果是 \u0026#39;a\u0026#39; // type A = \u0026#39;a\u0026#39; 当条件类型不确定时会返回所有的值， 即分配条件类型（Distributive Conditional Types）\ntype AB\u0026lt;T, U\u0026gt; = T extends U ? \u0026#34;a\u0026#34; : \u0026#34;b\u0026#34;; type All = AB\u0026lt;\u0026#34;x\u0026#34; | \u0026#34;y\u0026#34;, \u0026#34;x\u0026#34;\u0026gt;; // 非确定条件，可能是 \u0026#39;x\u0026#39; 或 \u0026#39;y\u0026#39; // type All = \u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; type Merge2\u0026lt;T, U\u0026gt; = T extends U ? T : \u0026#34;a\u0026#34;; type Values2 = Merge2\u0026lt;\u0026#34;x\u0026#34; | \u0026#34;y\u0026#34;, \u0026#34;x\u0026#34;\u0026gt;; // type Values2 = \u0026#34;a\u0026#34; | \u0026#34;x\u0026#34; type Merge3\u0026lt;T, U\u0026gt; = T extends U ? \u0026#34;a\u0026#34; : T; type Values3 = Merge3\u0026lt;\u0026#34;x\u0026#34; | \u0026#34;y\u0026#34;, \u0026#34;x\u0026#34;\u0026gt;; // type Values3 = \u0026#34;a\u0026#34; | \u0026#34;y\u0026#34; 工具 请参考官网\nPartial 可选 /** * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; // eg: interface Todo { title: string; description: string; } type TodoPreview = Partial\u0026lt;Todo\u0026gt;; const todo: TodoPreview = { title: \u0026#34;Clean room\u0026#34;, }; Required 必需 /** * Make all properties in T required */ type Required\u0026lt;T\u0026gt; = { [P in keyof T]-?: T[P]; }; // eg: interface Todo { title?: string; description?: string; } type TodoPreview = Required\u0026lt;Todo\u0026gt;; const todo: TodoPreview = { title: \u0026#34;Clean room\u0026#34;, }; // 类型“{ title: string; }”缺少类型“Required\u0026lt;Todo\u0026gt;”中的以下属性: description Readonly 只读 /** * Make all properties in T readonly */ type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P]; }; // eg: interface Todo { title: string; } type TodoPreview = Readonly\u0026lt;Todo\u0026gt;; const todo: TodoPreview = { title: \u0026#34;Clean room\u0026#34;, }; todo.title = \u0026#34;Hello\u0026#34;; // 无法分配到 \u0026#34;title\u0026#34; ，因为它是只读属性。 Pick 挑选 /** * From T, pick a set of properties whose keys are in the union K */ type Pick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; // eg: interface Todo { title: string; description: string; completed: boolean; } type TodoPreview = Pick\u0026lt;Todo, \u0026#34;title\u0026#34; | \u0026#34;completed\u0026#34;\u0026gt;; const todo: TodoPreview = { title: \u0026#34;Clean room\u0026#34;, completed: false, }; Record 记录 /** * Construct a type with a set of properties K of type T */ type Record\u0026lt;K extends keyof any, T\u0026gt; = { [P in K]: T; }; // eg: interface Todo { title: string; description: string; } type TodoName = \u0026#34;今天\u0026#34; | \u0026#34;明天\u0026#34;; type TodoPreview = Record\u0026lt;TodoName, Todo\u0026gt;; const todo: TodoPreview = { 今天: { title: \u0026#34;大雨\u0026#34;, description: \u0026#34;哗啦啦\u0026#34; }, 明天: { title: \u0026#34;大雨\u0026#34;, description: \u0026#34;哗啦啦\u0026#34; }, }; todo.今天.title; Exclude 排除 /** * Exclude from T those types that are assignable to U */ type Exclude\u0026lt;T, U\u0026gt; = T extends U ? never : T; // eg: type T0 = Exclude\u0026lt;\u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; | \u0026#34;d\u0026#34;, \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34;\u0026gt;; // \u0026#34;a\u0026#34; | \u0026#34;d\u0026#34; Extract 提取 /** * Extract from T those types that are assignable to U */ type Extract\u0026lt;T, U\u0026gt; = T extends U ? T : never; // eg: type T0 = Extract\u0026lt;\u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; | \u0026#34;d\u0026#34;, \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34;\u0026gt;; // type T0 = \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; Omit 忽略 /** * Construct a type with the properties of T except for those in type K. */ type Omit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; // eg: interface Todo { title: string; description: string; completed: boolean; } type TodoPreview = Omit\u0026lt;Todo, \u0026#34;description\u0026#34; | \u0026#34;completed\u0026#34;\u0026gt;; const todo: TodoPreview = { title: \u0026#34;Clean room\u0026#34;, }; ReturnType 返回类型 /** * Obtain the return type of a function type */ type ReturnType\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt; = T extends ( ...args: any ) =\u0026gt; infer R ? R : any; // eg: type T0 = ReturnType\u0026lt;() =\u0026gt; string\u0026gt;; // string type T1 = ReturnType\u0026lt;(s: string) =\u0026gt; void\u0026gt;; // void 常量断言 数组转 type const animals = [\u0026#34;cat\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;mouse\u0026#34;] as const; // const animals: readonly [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;mouse\u0026#39;] type Animal = (typeof animals)[number]; // type Animal = \u0026#39;cat\u0026#39; | \u0026#39;dog\u0026#39; | \u0026#39;mouse\u0026#39; 数组对象转 type const animals = [ { species: \u0026#34;cat\u0026#34;, name: \u0026#34;Fluffy\u0026#34; }, { species: \u0026#34;dog\u0026#34;, name: \u0026#34;Fido\u0026#34; }, { species: \u0026#34;mouse\u0026#34;, name: \u0026#34;Trevor\u0026#34; }, ] as const; type Animal = (typeof animals)[number][\u0026#34;species\u0026#34;]; // type Animal = \u0026#34;cat\u0026#34; | \u0026#34;dog\u0026#34; | \u0026#34;mouse\u0026#34; 对象转 type 取 key\nconst animals = { 1: \u0026#34;cat\u0026#34;, 2: \u0026#34;dog\u0026#34;, 3: \u0026#34;mouse\u0026#34; } as const; type animal = keyof typeof animals; 取 value\nconst animals = { 1: { name: \u0026#34;cat\u0026#34; }, 2: { name: \u0026#34;dog\u0026#34; }, 3: { name: \u0026#34;mouse\u0026#34; }, } as const; type key = keyof typeof animals; type value = (typeof animals)[key][\u0026#34;name\u0026#34;]; const 常量断言用法 索引访问类型 Indexed Access Types\n常量断言 const assertions\n数组转 type const animals = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;mouse\u0026#39;] as const // const animals: readonly [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;mouse\u0026#39;] type Animal = typeof animals[number] // type Animal = \u0026#39;cat\u0026#39; | \u0026#39;dog\u0026#39; | \u0026#39;mouse\u0026#39; 数组对象转 type const animals = [ { species: \u0026#39;cat\u0026#39;, name: \u0026#39;Fluffy\u0026#39; }, { species: \u0026#39;dog\u0026#39;, name: \u0026#39;Fido\u0026#39; }, { species: \u0026#39;mouse\u0026#39;, name: \u0026#39;Trevor\u0026#39; } ] as const type Animal = (typeof animals)[number][\u0026#34;species\u0026#34;]; // type Animal = \u0026#34;cat\u0026#34; | \u0026#34;dog\u0026#34; | \u0026#34;mouse\u0026#34; 对象转 type 取 key\nconst animals = {1: \u0026#39;cat\u0026#39;, 2: \u0026#39;dog\u0026#39;, 3: \u0026#39;mouse\u0026#39; } as const type animal = keyof typeof animals 取 value\nconst animals = {1: {name: \u0026#39;cat\u0026#39;}, 2: {name: \u0026#39;dog\u0026#39;}, 3: {name: \u0026#39;mouse\u0026#39;} } as const type key = keyof typeof animals type value = typeof animals[key][\u0026#39;name\u0026#39;] 泛型参数的默认类型 function createArray\u0026lt;T = string\u0026gt;(length: number, value: T): Array\u0026lt;T\u0026gt; { let result: T[] = []; for (let i = 0; i \u0026lt; length; i++) { result[i] = value; } return result; } map\u0026lt;U\u0026gt;(callbackfn: (value: T, index: number, array: T[]) =\u0026gt; U, thisArg?: any): U[]; reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =\u0026gt; T, initialValue: T): T; is 类型谓词 type predicates as 类型断言 type assertions type Fish = { swim: () =\u0026gt; void }; type Bird = { fly: () =\u0026gt; void }; // | 联合类型 declare function getSmallPet(): Fish | Bird; function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; } let pet = getSmallPet(); if (isFish(pet)) { pet.swim(); } else { pet.fly(); } 应用 export const isNumber = (value?: any): value is number =\u0026gt; { // or typeof value === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; Number.isFinite(value) return typeof value === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; !Number.isNaN(value); }; export const isString = (value?: any): value is string =\u0026gt; { return typeof value === \u0026#34;string\u0026#34;; }; ","permalink":"https://huing.github.io/posts/typescript/","summary":"基础类型 布尔值（boolean） 可选类型 true/false\nlet booleanExample: boolean = false; 数字（number） 可选类型 number\nlet numberExample: number = 6; 字符串（string） 可选类型 string\nlet stringExample: string = \u0026#34;Demo\u0026#34;; let stringTemplate: string = `template${Demo}`; void void 表示没有任何类型\nfunction sayHi(): void { console.log(\u0026#34;Hi!\u0026#34;); } let nothing: void = undefined; let unusable: void = null; // 不能将类型“null”分配给类型“void” let num: void = 1; // Error: 不能将类型“number”分配给类型“void” null 和 undefined let u: undefined = undefined; let n: null = null; 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 然而，当你指定了 strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。 许在某处你想传入一个 string 或 null 或 undefined，可以使用联合类型 string | null | undefined","title":"typescript"},{"content":"创建 index.cjs 文件 const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); /** * 递归遍历节点 */ function jsonToMarkdown(topic, level = 1) { if (!topic) return \u0026#34;\u0026#34;; let markdown = \u0026#34;\u0026#34;; // 添加标题 markdown += `${\u0026#34;#\u0026#34;.repeat(level)} ${topic.title}\\n\\n`; // 添加笔记 if (topic.notes?.plain.content) { markdown += `\u0026gt; ${topic.notes.plain.content}\\n\\n`; } // 添加标签 if (topic.labels \u0026amp;\u0026amp; topic.labels.length \u0026gt; 0) { markdown += `**Labels:** ${topic.labels.join(\u0026#34;, \u0026#34;)}\\n\\n`; } // 添加样式（简化处理） if (topic.style?.properties[\u0026#34;fo:font-style\u0026#34;] === \u0026#34;italic\u0026#34;) { markdown = markdown.replace(topic.title, `*${topic.title}*`); } if (topic.style?.properties[\u0026#34;fo:font-weight\u0026#34;] === \u0026#34;700\u0026#34;) { markdown = markdown.replace(topic.title, `**${topic.title}**`); } // 递归添加子主题 if (topic.children?.attached) { for (const child of topic.children.attached) { markdown += jsonToMarkdown(child, level + 1); } } // 递归添加总结 if (topic.children?.summary) { for (const summary of topic.children.summary) { markdown += jsonToMarkdown(summary, level + 1); } } return markdown; } function entry() { const filename = process.argv[2].replace(\u0026#34;.xmind\u0026#34;, \u0026#34;\u0026#34;); const outputPath = `${filename}.md`; try { const filePath = path.join(__dirname, \u0026#34;/zip/content.json\u0026#34;); // 添加文件存在检查 if (!fs.existsSync(filePath)) { throw new Error(\u0026#34;找不到解压后的 content.json 文件\u0026#34;); } const buffer = fs.readFileSync(filePath); const contentJsonArray = JSON.parse(buffer.toString(\u0026#34;utf8\u0026#34;)); let content = \u0026#34;\u0026#34;; for (const contentJson of contentJsonArray) { content += jsonToMarkdown(contentJson.rootTopic, 1); } fs.writeFileSync(outputPath, content); console.log(`转换完成，已生成 ${outputPath}`); } catch (error) { console.error(\u0026#34;转换过程中出错:\u0026#34;, error.message); process.exit(1); } } entry(); 创建文件 index.sh 文件 #!/bin/bash xmind_file=$1 # 检查是否提供了文件参数 if [ -z \u0026#34;$xmind_file\u0026#34; ]; then echo \u0026#34;错误: 请提供 xmind 文件路径\u0026#34; exit 1 fi # 确保 zip 目录存在 mkdir -p \u0026#34;$(pwd)/zip\u0026#34; echo \u0026#34;开始处理文件: $xmind_file\u0026#34; tar -xvf $xmind_file -C \u0026#34;$(pwd)/zip\u0026#34; \u0026amp;\u0026amp; node index.cjs $xmind_file 执行 sh 脚本 ./index.sh test.xmind 运行结果 xmind 文件会解压到 zip 目录下 在同一目录下输出 test.md 文件 ","permalink":"https://huing.github.io/posts/%E5%A6%82%E4%BD%95%E6%8A%8Axmind%E8%BD%AC%E6%88%90md/","summary":"创建 index.cjs 文件 const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); /** * 递归遍历节点 */ function jsonToMarkdown(topic, level = 1) { if (!topic) return \u0026#34;\u0026#34;; let markdown = \u0026#34;\u0026#34;; // 添加标题 markdown += `${\u0026#34;#\u0026#34;.repeat(level)} ${topic.title}\\n\\n`; // 添加笔记 if (topic.notes?.plain.content) { markdown += `\u0026gt; ${topic.notes.plain.content}\\n\\n`; } // 添加标签 if (topic.labels \u0026amp;\u0026amp; topic.labels.length \u0026gt; 0) { markdown += `**Labels:** ${topic.labels.join(\u0026#34;, \u0026#34;)}\\n\\n`; } // 添加样式（简化处理） if (topic.style?.properties[\u0026#34;fo:font-style\u0026#34;] === \u0026#34;italic\u0026#34;) { markdown = markdown.replace(topic.title, `*${topic.","title":"如何把xmind转成md"},{"content":"IntersectionObserver const imageObserver = new IntersectionObserver((entries, observer) =\u0026gt; { entries.forEach((entry) =\u0026gt; { if (entry.isIntersecting) { const img = entry.target; img.src = img.dataset.src; // 加载真实图片 observer.unobserve(img); // 停止观察该图片 } }); }); // 获取所有带有 data-src 属性的图片 document.querySelectorAll(\u0026#34;img[data-src]\u0026#34;).forEach((img) =\u0026gt; { imageObserver.observe(img); }); MutationObserver MutationObserver 用于监视 DOM 树的变化，可以监听元素的属性变化、子节点的增删改、文本内容的修改等。\n// 创建一个观察器实例 const observer = new MutationObserver((mutations) =\u0026gt; { mutations.forEach((mutation) =\u0026gt; { // mutation.type 可能是 \u0026#39;childList\u0026#39;、\u0026#39;attributes\u0026#39; 或 \u0026#39;characterData\u0026#39; console.log(\u0026#34;DOM 发生变化:\u0026#34;, mutation.type); if (mutation.type === \u0026#34;childList\u0026#34;) { console.log(\u0026#34;添加的节点:\u0026#34;, mutation.addedNodes); console.log(\u0026#34;移除的节点:\u0026#34;, mutation.removedNodes); } else if (mutation.type === \u0026#34;attributes\u0026#34;) { console.log(\u0026#34;变化的属性:\u0026#34;, mutation.attributeName); } }); }); // 配置观察选项 const config = { attributes: true, // 监听属性变化 childList: true, // 监听子节点增删 subtree: true, // 监听所有后代节点 characterData: true, // 监听文本内容变化 }; // 开始观察目标节点 const targetNode = document.getElementById(\u0026#34;some-id\u0026#34;); observer.observe(targetNode, config); // 停止观察 // observer.disconnect(); MutationObserver 常用于：\n监控 DOM 变化以实现动态功能 实现虚拟 DOM 的差异检测 监听第三方脚本对 DOM 的修改 实现自动化测试 PerformanceObserver https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver\nPerformanceObserver entry.entryType\nentry.entryType\nnew PerformanceObserver((entryList) =\u0026gt; { for (const entry of entryList.getEntries()) { console.log(entry); } }).observe({ entryTypes: [\u0026#34;paint\u0026#34;, \u0026#34;largest-contentful-paint\u0026#34;, \u0026#34;first-input\u0026#34;], }); new PerformanceObserver((entryList) =\u0026gt; { for (const entry of entryList.getEntries()) { console.log(entry); } }).observe({ entryTypes: [\u0026#34;mark\u0026#34;, \u0026#34;measure\u0026#34;] }); new PerformanceObserver((entryList) =\u0026gt; { for (const entry of entryList.getEntries()) { console.log(\u0026#34;Layout shift:\u0026#34;, entry); } }).observe({ type: \u0026#34;layout-shift\u0026#34;, buffered: true }); ResizeObserver window.requestAnimationFrame window.cancelAnimationFrame ","permalink":"https://huing.github.io/posts/html/webapi/","summary":"IntersectionObserver const imageObserver = new IntersectionObserver((entries, observer) =\u0026gt; { entries.forEach((entry) =\u0026gt; { if (entry.isIntersecting) { const img = entry.target; img.src = img.dataset.src; // 加载真实图片 observer.unobserve(img); // 停止观察该图片 } }); }); // 获取所有带有 data-src 属性的图片 document.querySelectorAll(\u0026#34;img[data-src]\u0026#34;).forEach((img) =\u0026gt; { imageObserver.observe(img); }); MutationObserver MutationObserver 用于监视 DOM 树的变化，可以监听元素的属性变化、子节点的增删改、文本内容的修改等。\n// 创建一个观察器实例 const observer = new MutationObserver((mutations) =\u0026gt; { mutations.forEach((mutation) =\u0026gt; { // mutation.type 可能是 \u0026#39;childList\u0026#39;、\u0026#39;attributes\u0026#39; 或 \u0026#39;characterData\u0026#39; console.log(\u0026#34;DOM 发生变化:\u0026#34;, mutation.type); if (mutation.type === \u0026#34;childList\u0026#34;) { console.","title":"WebApi"},{"content":"React.Children.map(children, (child, index) =\u0026gt; { if (!React.isValidElement(child)) return null; return React.cloneElement(child, { ...child.props, onClick: () =\u0026gt; {}, }); }); ","permalink":"https://huing.github.io/posts/react/isvalidelement/","summary":"React.Children.map(children, (child, index) =\u0026gt; { if (!React.isValidElement(child)) return null; return React.cloneElement(child, { ...child.props, onClick: () =\u0026gt; {}, }); }); ","title":"isValidElement"},{"content":"","permalink":"https://huing.github.io/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%B7%A8%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","summary":"","title":"跨端解决方案"},{"content":"chrome devtools\nandroid simulator\nios simulator\nhybrid 是啥\nweex\n","permalink":"https://huing.github.io/posts/react-native/","summary":"chrome devtools\nandroid simulator\nios simulator\nhybrid 是啥\nweex","title":"调试"},{"content":"side rendering\nssr ssr 是什么\nssg\nesr\nrsr\ndocker lpass jenkins node cdn 静态托管\nnextjs(react)\nnuxtjs(vue)\nbff 网关\nk8s v8s\n服务器，镜像，容器\nwebpack5 module federation 模块联邦，webpack5 的一个新特性，可实现跨应用共享代码\nMicroApp 、single-spa、qiankuan\n无服务器（Serverless）\nRPC 远程过程调用（英语：Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC 是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统\n云计算的三种模式 云计算模式所具备的 5 个基本特征（按需自助服务、广泛的网络访问、资源共享、快速的可伸缩性和可度量的服务）、3 种服务模式 SaaS（软件即服务）、PaaS（平台即服务）和 IaaS（基础设施即服务）和 4 种部署方式（私有云、社区云、公有云和混合云），而云服务则是在这个云平台上发布出来的供用户使用的产品服务\nIaaS（Infrastructure as a server） 基础设施即服务\nPaaS（Platform as a Server） 平台即服务\nSaaS（Software as a Server） 软件即服务\n区别和关系 云计算(Cloud Computing) 是一种概念和技术，提供按需的计算资源和服务。 云服务(Cloud Service) 是云计算的具体实现形式，包括 IaaS、PaaS 和 SaaS 等不同类型的云服务。 云函数(Cloud Function) 是一种特定的云服务类型，属于\u0026quot;无服务器计算\u0026quot;(Serverless) 模型，适用于事件驱动的任务。 云计算（概念和技术模型） ├── 云服务（具体实现形式） │ ├── IaaS │ ├── PaaS │ └── SaaS └── 云函数（特定服务类型） └── Serverless 的一种实现\nDSL (Domain Specific Language) 特定领域语言\n","permalink":"https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E5%95%A5/","summary":"side rendering\nssr ssr 是什么\nssg\nesr\nrsr\ndocker lpass jenkins node cdn 静态托管\nnextjs(react)\nnuxtjs(vue)\nbff 网关\nk8s v8s\n服务器，镜像，容器\nwebpack5 module federation 模块联邦，webpack5 的一个新特性，可实现跨应用共享代码\nMicroApp 、single-spa、qiankuan\n无服务器（Serverless）\nRPC 远程过程调用（英语：Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC 是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统\n云计算的三种模式 云计算模式所具备的 5 个基本特征（按需自助服务、广泛的网络访问、资源共享、快速的可伸缩性和可度量的服务）、3 种服务模式 SaaS（软件即服务）、PaaS（平台即服务）和 IaaS（基础设施即服务）和 4 种部署方式（私有云、社区云、公有云和混合云），而云服务则是在这个云平台上发布出来的供用户使用的产品服务\nIaaS（Infrastructure as a server） 基础设施即服务\nPaaS（Platform as a Server） 平台即服务\nSaaS（Software as a Server） 软件即服务\n区别和关系 云计算(Cloud Computing) 是一种概念和技术，提供按需的计算资源和服务。 云服务(Cloud Service) 是云计算的具体实现形式，包括 IaaS、PaaS 和 SaaS 等不同类型的云服务。 云函数(Cloud Function) 是一种特定的云服务类型，属于\u0026quot;无服务器计算\u0026quot;(Serverless) 模型，适用于事件驱动的任务。 云计算（概念和技术模型） ├── 云服务（具体实现形式） │ ├── IaaS │ ├── PaaS │ └── SaaS └── 云函数（特定服务类型） └── Serverless 的一种实现","title":"渲染"},{"content":"","permalink":"https://huing.github.io/posts/%E6%80%A7%E8%83%BD/%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","summary":"","title":"骨架屏"},{"content":"RAIL 模型\nLighthouse 指标\nDevTools\nPWA\nService Worker\n考察\n白屏影响用户率\njs 错误影响用户率\nLCP Largest Contentful Paint 最大内容绘制\nCLS Cumulative Layout Shift 累积布局偏移\nTTI Time To Interactive 页面加载开始到页面处于完全可交互状态所花费的时间\nFCP First Contentful Paint 首次有内容渲染\n不考察\nFP First Paint 首次渲染\nFMP First Meaningful Paint 首次绘制有意义内容的时间\nINP Interaction to Next Paint\n与下一次绘制的交互 INP 会在页面生命周期内观察用户与网页进行的所有点击、点按和键盘互动的延迟时间，并报告最长持续时间。INP 较低意味着页面始终能够快速响应大多数用户互动\n","permalink":"https://huing.github.io/posts/%E6%80%A7%E8%83%BD/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","summary":"RAIL 模型\nLighthouse 指标\nDevTools\nPWA\nService Worker\n考察\n白屏影响用户率\njs 错误影响用户率\nLCP Largest Contentful Paint 最大内容绘制\nCLS Cumulative Layout Shift 累积布局偏移\nTTI Time To Interactive 页面加载开始到页面处于完全可交互状态所花费的时间\nFCP First Contentful Paint 首次有内容渲染\n不考察\nFP First Paint 首次渲染\nFMP First Meaningful Paint 首次绘制有意义内容的时间\nINP Interaction to Next Paint\n与下一次绘制的交互 INP 会在页面生命周期内观察用户与网页进行的所有点击、点按和键盘互动的延迟时间，并报告最长持续时间。INP 较低意味着页面始终能够快速响应大多数用户互动","title":"性能指标"},{"content":"单元测试\n集成测试\nE2E 测试\njest\nenzyme\npuppeteer\n","permalink":"https://huing.github.io/posts/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%B5%8B%E8%AF%95/","summary":"单元测试\n集成测试\nE2E 测试\njest\nenzyme\npuppeteer","title":"测试"},{"content":"","permalink":"https://huing.github.io/posts/react/react-router/","summary":"","title":"React-Router"},{"content":"npm script\nci cd\n","permalink":"https://huing.github.io/posts/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/","summary":"npm script\nci cd","title":"自动化构建"},{"content":"构建工具模块化打包\nwebpack\nrollup\nparcel\n","permalink":"https://huing.github.io/posts/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85/","summary":"构建工具模块化打包\nwebpack\nrollup\nparcel","title":"模块化打包"},{"content":"git log \u0026ndash;pretty=oneline \u0026ndash;graph\ngit reflog 记录命令历史\n查看项目邮箱，用户名\ngit config user.name git config user.email git checkout\ngit checkout --readme.text 丢弃工作区修改 git checkout -b dev 创建并切换到dev分支 git checkout -b dev origin/dev 创建远程origin的dev分支到本地 git branch\ngit branch --set-upstream-to=origin/dev dev 链接远程分支 git branch -a 查看所有分支 git branch -v 查看所有本地分支及其最后一次提交 git branch -r 查看所有远程分支 git branch --merged 查看已合并到当前分支的分支列表 git branch --no-merged 显示还未合并到当前分支的分支列表 git branch -d dev 删除分支 git merge dev 合并分支\ngit merge --no-ff dev 在 dev 分支上生成一个新节点 git merge --no-ff -m \u0026#34;merge with no-ff\u0026#34; dev git merge --squash dev (git commit) git stash 存储工作区内容\ngit stash list 查看列表 git stash apply 只弹出不删除 git stash pop 弹出并删除（不存在冲突的情况下） git fetch\ngit fetch --all git fetch origin --prune 同步删除的分支 git pull\ngit pull --rebase origin master git pull -p 删除已经不存在的远程分支 git push (-u) origin master git push origin \u0026ndash;tags \u0026ndash;force git push origin \u0026ndash;all \u0026ndash;force git push origin \u0026ndash;delete feature 删除远程分支\ngit commit\ngit commit -m \u0026#34;do what\u0026#34; 提交文件到仓库 git commit --amend 修改注释 git init 这个目录变成 Git 可以管理的仓库 git add file.txt 把文件添加到仓库 git status 查看当前仓库状态 git diff file.txt 查看不同\ngit reset head file.txt 把暂存区的修改撤销，重新放回工作区 git reset \u0026ndash;hard HEAD^ 删除工作空间改动代码,撤销 commit,撤销 git add . git reset \u0026ndash;soft HEAD^ 不删除工作空间改动代码,撤销 commit,不撤销 git add . git reset \u0026ndash;mixed HEAD^ 不删除工作空间改动代码,撤销 commit,并且撤销 git add . 默认参数\ngit remote add origin git@github.com:username/repname.git git remote -v 查看地址 git remote remove origin git remote rename git remote show origin\ncat file.txt 查看文件内容\ngit rm file.txt 删除版本库文件 git rm 停止追踪指定文件，但该文件会保留在工作区 git rm -r \u0026ndash;cached dir git rm \u0026ndash;cached file\ngit tag 打标签 git tag tagname git tag tagname commitId git tag \u0026ndash;delete tagname\ngit flow 工作流程 git flow init\nfeature\ngit flow feature start 1.0.0 从develop开始一个新分支 git flow feature publish 1.0.0 推送分支 git flow feature finish 1.0.0 把feature合到develop release\ngit flow release start 1.0.0 从develop开始一个新分支 git flow release finish 1.0.0 把release合到develop，把release合到master hotfix 分支\ngit flow hotfix start 1.0.0 git flow hotfix finish 1.0.0 工作结束推送分支到远程\ngit push origin --tags git push master git push develop git cherry-pick 场景： a、代码敲完后发现写错分支了，本应该在分支 A 的误写在了 B 分支！ b、有些 commit 不希望在本次版本中发布 操作： 1、git log 先在 B 分支找到那个 commit，复制出 commitID 2、git checkout A 切换到 A 分支 3、git cherry-pick commitID 把 B 分支上的 commitID 合并过来 4、git reset —hard commitID 回到 B 分支把写错地方的 commitID 删除掉\ngit rebase 场景：删除 commit 记录中的某一条，比如从早到现在 A、B、C 三条记录，删除 B 又不影响 C 操作： 1、 git log 找到 A 的 commitID 2、git rebase -i 回退到 A 3、编辑将需要删除的行，前面的 pick 改为 drop。保存并退出 4、至此本地仓库已生效，如果需要同步远程仓库，执行 git push -f origin 进行远程强制更新\n查看存储库中的大文件 $ git rev-list \u0026ndash;objects \u0026ndash;all | grep -E git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk '{print$1}' | sed ':a;N;$!ba;s/\\n/|/g'\n改写历史，去除大文件 $ git filter-branch \u0026ndash;tree-filter \u0026lsquo;rm -f path/to/large/files\u0026rsquo; \u0026ndash;tag-name-filter cat \u0026ndash; \u0026ndash;all $ git filter-branch \u0026ndash;force \u0026ndash;index-filter \u0026lsquo;git rm \u0026ndash;cached \u0026ndash;ignore-unmatch path-to-your-remove-file\u0026rsquo; \u0026ndash;prune-empty \u0026ndash;tag-name-filter cat \u0026ndash; \u0026ndash;all\n","permalink":"https://huing.github.io/posts/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","summary":"git log \u0026ndash;pretty=oneline \u0026ndash;graph\ngit reflog 记录命令历史\n查看项目邮箱，用户名\ngit config user.name git config user.email git checkout\ngit checkout --readme.text 丢弃工作区修改 git checkout -b dev 创建并切换到dev分支 git checkout -b dev origin/dev 创建远程origin的dev分支到本地 git branch\ngit branch --set-upstream-to=origin/dev dev 链接远程分支 git branch -a 查看所有分支 git branch -v 查看所有本地分支及其最后一次提交 git branch -r 查看所有远程分支 git branch --merged 查看已合并到当前分支的分支列表 git branch --no-merged 显示还未合并到当前分支的分支列表 git branch -d dev 删除分支 git merge dev 合并分支\ngit merge --no-ff dev 在 dev 分支上生成一个新节点 git merge --no-ff -m \u0026#34;merge with no-ff\u0026#34; dev git merge --squash dev (git commit) git stash 存储工作区内容","title":"基本命令"},{"content":"ajax\nfetch\nkeep-alive\nnavigator.setbean\n","permalink":"https://huing.github.io/posts/javascript/%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82/","summary":"ajax\nfetch\nkeep-alive\nnavigator.setbean","title":"接口请求"},{"content":"DOM 是文档对象模型，是 HTML 和 XML 文档的编程接口。\nDOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构化树。\nDOM 是 HTML 和 XML 文档的编程接口。\n","permalink":"https://huing.github.io/posts/html/dom%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","summary":"DOM 是文档对象模型，是 HTML 和 XML 文档的编程接口。\nDOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构化树。\nDOM 是 HTML 和 XML 文档的编程接口。","title":"DOM文档对象模型"},{"content":"line-height 如何继承 line-height 具体值 30px 子元素继承该值\nline-height 比例 1.5 子元素继承该比例\nline-height 百分比 200% 子元素继承 父元素 font-size * 200% 的值\ncss 值与单位 绝对长度单位 与任何东西都没有关系 cm mm pt: 点 px: 像素 相对长度单位 em: 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width rem: 根元素的字体大小 设置 html 字体的大小为百分比 用 js 动态设置 html 字体大小 浏览器默认字体大小 16px,最小 12px,css3 并未提及 字重\n100 - Thin 200 - Extra Light (Ultra Light) 300 - Light 400 - Normal 500 - Medium 600 - Semi Bold (Demi Bold) 700 - Bold 800 - Extra Bold (Ultra Bold) 900 - Black (Heavy)\n","permalink":"https://huing.github.io/posts/css/","summary":"line-height 如何继承 line-height 具体值 30px 子元素继承该值\nline-height 比例 1.5 子元素继承该比例\nline-height 百分比 200% 子元素继承 父元素 font-size * 200% 的值\ncss 值与单位 绝对长度单位 与任何东西都没有关系 cm mm pt: 点 px: 像素 相对长度单位 em: 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width rem: 根元素的字体大小 设置 html 字体的大小为百分比 用 js 动态设置 html 字体大小 浏览器默认字体大小 16px,最小 12px,css3 并未提及 字重\n100 - Thin 200 - Extra Light (Ultra Light) 300 - Light 400 - Normal 500 - Medium 600 - Semi Bold (Demi Bold) 700 - Bold 800 - Extra Bold (Ultra Bold) 900 - Black (Heavy)","title":"基本语法"},{"content":"WebView 是 Android 和 iOS 平台上的原生组件，用于显示网页内容。\nWebView 是移动应用开发中的一个重要组件，它能够在原生应用中嵌入网页内容。简单来说，它就像是一个迷你的浏览器，被嵌入在移动应用程序中。\nWebView 的主要特点 内嵌浏览器功能\n可以加载和显示网页 支持基本的网页浏览功能（前进、后退、刷新等） 支持 JavaScript 执行 混合开发支持\n支持原生代码和网页代码的交互 可以实现混合应用（Hybrid App）开发 便于快速开发和维护 常见应用场景\n在 App 中显示 HTML 内容 构建混合应用 显示富文本内容 加载在线帮助文档 优势与限制 优势 开发效率高 内容易于更新 跨平台兼容性好 减少应用体积 限制 性能相比原生界面略差 内存占用较大 可能存在安全隐患 平台差异 Android WebView 基于 Chromium 引擎 可通过 WebSettings 进行详细配置 支持与 JavaScript 双向交互 iOS WKWebView 基于 WebKit 引擎 性能优于旧版 UIWebView 提供现代化的网页处理能力 混合应用（Hybrid App）详解 什么是混合应用？ 混合应用（Hybrid App）是一种结合了原生应用（Native App）和 Web 应用优点的开发方式。它的核心架构是：\n原生应用外壳（Native Shell） 内嵌的 WebView 组件 Web 页面内容 工作原理 架构层面\n应用的外层框架使用原生代码开发（如 Java/Kotlin 或 Swift/Objective-C） 内部内容使用 Web 技术开发（HTML、CSS、JavaScript） 通过 WebView 将 Web 内容嵌入原生应用中 通信机制\nJavaScript Bridge：实现 Web 代码和原生代码的双向通信 原生 API 调用：Web 页面可以调用设备原生功能 数据传递：支持原生代码和 Web 代码之间的数据交换 常见应用场景 新闻资讯类应用\n内容频繁更新 界面布局相对简单 需要快速发布新功能 电商类应用\n商品展示页面 营销活动页面 支付流程页面 企业级应用\n管理后台 数据展示界面 配置页面 优缺点对比 优点 开发成本低 跨平台复用性高 维护更新方便 上架审核简单 缺点 性能不如纯原生应用 用户体验可能略差 复杂功能实现受限 依赖网络环境 app 开发 原生开发（Native）\niOS: Swift/Objective-C Android: Java/Kotlin 混合开发（Hybrid）\n技术栈：HTML5 + WebView jsBridge：实现 Web 代码和原生代码的双向通信 原生 API：Web 页面可以调用设备原生功能 数据传递：支持原生代码和 Web 代码之间的数据交换 跨平台开发\nreact native flutter 小程序 weex uniapp taro 其他 ","permalink":"https://huing.github.io/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F/webview/","summary":"WebView 是 Android 和 iOS 平台上的原生组件，用于显示网页内容。\nWebView 是移动应用开发中的一个重要组件，它能够在原生应用中嵌入网页内容。简单来说，它就像是一个迷你的浏览器，被嵌入在移动应用程序中。\nWebView 的主要特点 内嵌浏览器功能\n可以加载和显示网页 支持基本的网页浏览功能（前进、后退、刷新等） 支持 JavaScript 执行 混合开发支持\n支持原生代码和网页代码的交互 可以实现混合应用（Hybrid App）开发 便于快速开发和维护 常见应用场景\n在 App 中显示 HTML 内容 构建混合应用 显示富文本内容 加载在线帮助文档 优势与限制 优势 开发效率高 内容易于更新 跨平台兼容性好 减少应用体积 限制 性能相比原生界面略差 内存占用较大 可能存在安全隐患 平台差异 Android WebView 基于 Chromium 引擎 可通过 WebSettings 进行详细配置 支持与 JavaScript 双向交互 iOS WKWebView 基于 WebKit 引擎 性能优于旧版 UIWebView 提供现代化的网页处理能力 混合应用（Hybrid App）详解 什么是混合应用？ 混合应用（Hybrid App）是一种结合了原生应用（Native App）和 Web 应用优点的开发方式。它的核心架构是：\n原生应用外壳（Native Shell） 内嵌的 WebView 组件 Web 页面内容 工作原理 架构层面","title":"WebView"},{"content":"标题 devServer.host: \u0026lsquo;0,0,0,0\u0026rsquo;\n可以访问所有的主机地址\ndevServer.host: \u0026rsquo;localhost'\n只能访问自己的\n","permalink":"https://huing.github.io/posts/host/","summary":"标题 devServer.host: \u0026lsquo;0,0,0,0\u0026rsquo;\n可以访问所有的主机地址\ndevServer.host: \u0026rsquo;localhost'\n只能访问自己的","title":"host"},{"content":"HeadlessBrowser Headless Browser(无头浏览器)是一种没有图形用户界面(GUI)的浏览器，可以在后台运行并通过程序代码控制。\n主要特点 无界面运行：在服务器等没有图形界面的环境中运行 完整功能：支持 JavaScript 执行、DOM 操作等完整的浏览器功能 自动化支持：可以通过代码完全控制浏览器行为 性能优势：相比传统浏览器占用更少的系统资源 应用场景 自动化测试\n端到端测试(E2E Testing) 界面功能测试 跨浏览器兼容性测试 网页爬虫\n抓取动态网页内容 模拟用户行为 处理需要 JavaScript 渲染的页面 网页截图与 PDF 生成\n自动化网页截图 生成网页 PDF 报告 页面内容导出 性能监控\n页面加载性能分析 资源使用情况监控 网络请求追踪 常用实现 Chrome Headless const puppeteer = require(\u0026#34;puppeteer\u0026#34;); (async () =\u0026gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(\u0026#34;https://example.com\u0026#34;); await page.screenshot({ path: \u0026#34;screenshot.png\u0026#34; }); await browser.close(); })(); Firefox Headless const firefox = require(\u0026#34;selenium-webdriver/firefox\u0026#34;); const options = new firefox.Options(); options.headless(); Playwright (支持多浏览器) const { chromium } = require(\u0026#34;playwright\u0026#34;); (async () =\u0026gt; { const browser = await chromium.launch(); const page = await browser.newPage(); await page.goto(\u0026#34;https://example.com\u0026#34;); await browser.close(); })(); V8 引擎 V8 是由 Google 开发的开源 JavaScript 引擎，最初是为 Google Chrome 浏览器打造。它是一个高性能的 JavaScript 和 WebAssembly 引擎，也被广泛应用于 Node.js 运行时环境。\n主要特点 高性能执行\n采用即时编译（JIT）技术 直接将 JavaScript 代码编译成机器码 动态优化代码执行 跨平台支持\n支持 x86、ARM、MIPS 等多种指令集架构 适用于 32 位和 64 位系统 可运行在 Windows、Mac、Linux 等多个平台 工作原理 编译流程\n解析：生成抽象语法树（AST） 解释：通过 Ignition 解释器生成字节码 编译：使用 TurboFan 编译器生成机器码 优化：运行时动态优化代码执行 编译器组件\nIgnition：基础解释器 TurboFan：优化编译器 SparkPlug：快速基线编译器 Maglev：中间层编译器（2023 年新增） 应用场景 浏览器\nChrome Microsoft Edge Opera Brave 服务端\nNode.js Deno Cloud 环境（如 Google Apps Script） 桌面应用\nElectron 框架 Visual Studio Code Atom 编辑器 性能优化特性 内联缓存 隐藏类 垃圾回收（分代增量收集器） 代码优化和重优化 WebAssembly 支持 ","permalink":"https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","summary":"HeadlessBrowser Headless Browser(无头浏览器)是一种没有图形用户界面(GUI)的浏览器，可以在后台运行并通过程序代码控制。\n主要特点 无界面运行：在服务器等没有图形界面的环境中运行 完整功能：支持 JavaScript 执行、DOM 操作等完整的浏览器功能 自动化支持：可以通过代码完全控制浏览器行为 性能优势：相比传统浏览器占用更少的系统资源 应用场景 自动化测试\n端到端测试(E2E Testing) 界面功能测试 跨浏览器兼容性测试 网页爬虫\n抓取动态网页内容 模拟用户行为 处理需要 JavaScript 渲染的页面 网页截图与 PDF 生成\n自动化网页截图 生成网页 PDF 报告 页面内容导出 性能监控\n页面加载性能分析 资源使用情况监控 网络请求追踪 常用实现 Chrome Headless const puppeteer = require(\u0026#34;puppeteer\u0026#34;); (async () =\u0026gt; { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(\u0026#34;https://example.com\u0026#34;); await page.screenshot({ path: \u0026#34;screenshot.png\u0026#34; }); await browser.close(); })(); Firefox Headless const firefox = require(\u0026#34;selenium-webdriver/firefox\u0026#34;); const options = new firefox.","title":"浏览器的工作原理"},{"content":"网络是如何连接的 浏览器处理流程 当我们在浏览器中输入一个 URL(如www.example.com)后,浏览器会经过以下步骤:\n解析 URL\n识别协议(http/https) 识别域名(example.com) 识别资源路径(/) DNS 解析过程\n首先检查浏览器 DNS 缓存 检查操作系统 DNS 缓存 检查路由器缓存 向 ISP 的 DNS 服务器发起递归查询 获取目标服务器的 IP 地址 建立连接\n与目标服务器建立 TCP 连接(三次握手) 如果是 HTTPS,还需要进行 TLS 握手 发送 HTTP 请求\n浏览器构建 HTTP 请求报文 通过网络发送到服务器 浏览器渲染过程\n解析 HTML 构建 DOM 树(DOM Tree) 解析 CSS 构建 CSSOM(CSS Object Model) 合并 DOM 和 CSSOM 构建渲染树(Render Tree) 布局(Layout):计算每个节点的几何信息 绘制(Painting):将渲染树绘制到屏幕上 DNS (Domain Name System) 原理 DNS 是一个分布式数据库,主要功能是将域名转换为 IP 地址。解析过程如下:\n本地 DNS 缓存查询 递归 DNS 服务器查询 根域名服务器查询 顶级域名服务器查询 权威 DNS 服务器查询 DNS 记录类型 DNS 系统中最常用的两种记录类型是 A 记录和 CNAME 记录：\nA 记录 (Address Record)\n直接将域名指向一个 IPv4 地址\n例如：\nblog.example.com. A 185.31.17.133 CNAME 记录 (Canonical Name)\n将一个域名指向另一个域名\n可以指向另一个 CNAME 记录或 A 记录\n继承目标域名的完整解析链\n示例：\nblog.example.com. CNAME cdn.example.com. cdn.example.com. CNAME cdn.provider.net. cdn.provider.net. A 185.31.17.133 使用场景 A 记录：当你需要将域名直接指向 IP 地址时使用 CNAME 记录：当你需要将域名指向另一个域名时使用，常用于 CDN 服务或者需要动态改变目标服务器 IP 的场景 IP (Internet Protocol) 寻址 IP 是网络层协议，IP 地址是一串数字\nIP 协议负责:\n为网络中的设备分配唯一的地址 数据包的路由和转发 处理数据包的分片和重组 ISP (Internet Service Provider) 互联网服务提供商\n为个人和企业提供互联网接入服务的公司或组织 例如：中国电信、中国联通、中国移动等 主要提供宽带接入、域名解析、电子邮件等基础互联网服务 NSP (Network Service Provider) 网络服务提供商\n主要为 ISP 提供网络基础设施和骨干网络服务 运营和维护大规模的网络基础设施 负责处理跨区域、跨国的网络通信 TCP (Transmission Control Protocol) TCP 是一个可靠的传输层协议，通过三次握手建立连接，确保数据传输的可靠性。\nTCP 三次握手过程 第一步：SYN (同步序列编号)\n客户端发送 SYN 包到服务器 设置 SYN 标志位为 1 包含一个随机的序列号 ACK 标志位为 0 第二步：SYN-ACK (同步序列编号确认)\n服务器收到 SYN 后，发送 SYN-ACK 包 设置 SYN 和 ACK 标志位都为 1 确认客户端的序列号 服务器也生成自己的序列号 第三步：ACK (确认)\n客户端收到 SYN-ACK 后，发送 ACK 包 设置 ACK 标志位为 1 确认服务器的序列号 TCP 连接正式建立 TCP 连接的特点 可靠性：通过确认和重传机制确保数据可靠传输 全双工通信：建立连接后，双方可以同时收发数据 面向连接：传输数据前必须先建立连接 流量控制：通过窗口大小控制数据传输速率 常见的 TCP 应用协议 HTTP/HTTPS FTP（文件传输） SMTP（邮件发送） SSH（安全 shell） IMAP/POP3（邮件接收） TCP 连接释放 断开连接时也需要经过类似的握手过程：\n客户端发送 FIN 请求断开连接 服务器回复 FIN+ACK 客户端确认，发送 ACK 网络分层模型 网络通信采用分层的结构，最常见的是 OSI 七层模型，从底层到顶层分别是：\n1. 物理层 (Physical Layer) 负责比特流的传输 定义物理介质、接口和规范 处理原始的电信号、光信号等物理量 2. 数据链路层 (Data Link Layer) 负责节点之间的数据传输 差错检测和控制 常见协议： MAC (媒体访问控制) ARP (地址解析协议) PPP (点对点协议) 3. 网络层 (Network Layer) 负责数据包的路由和转发 主要协议： IP (网际协议) ICMP (互联网控制消息协议) IPsec (互联网安全协议) 处理网络地址、路由选择 4. 传输层 (Transport Layer) 提供端到端的通信服务 负责数据的分段、传输、流控和差错控制 主要协议： TCP (传输控制协议)：可靠、面向连接 UDP (用户数据报协议)：不可靠、无连接 SCTP (流控制传输协议) QUIC (快速 UDP 网络连接) 5. 会话层 (Session Layer) 建立、管理和终止会话 提供对话控制和同步功能 常见协议： NetBIOS RPC (远程过程调用) 6. 表示层 (Presentation Layer) 数据格式转换和加密 负责数据的编码、压缩和加密 常见协议： TLS/SSL ASCII JPEG、MPEG 等 7. 应用层 (Application Layer) 为应用程序提供网络服务 直接面向用户的接口 常见协议： HTTP/HTTPS (网页访问) FTP (文件传输) SMTP (邮件发送) DNS (域名解析) SSH (安全 shell) 数据封装过程 在数据传输过程中，数据在各层之间传递时会经过封装和解封装：\n应用层数据 加入传输层头部（TCP/UDP 头） 加入网络层头部（IP 头） 加入数据链路层头部和尾部 转换为物理层的比特流传输 每一层都为上一层提供服务，同时使用下一层提供的服务，形成了一个完整的网络通信体系。\nTODO 网络分层模型是什么时候参与到浏览器请求的过程中的\n","permalink":"https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84/","summary":"网络是如何连接的 浏览器处理流程 当我们在浏览器中输入一个 URL(如www.example.com)后,浏览器会经过以下步骤:\n解析 URL\n识别协议(http/https) 识别域名(example.com) 识别资源路径(/) DNS 解析过程\n首先检查浏览器 DNS 缓存 检查操作系统 DNS 缓存 检查路由器缓存 向 ISP 的 DNS 服务器发起递归查询 获取目标服务器的 IP 地址 建立连接\n与目标服务器建立 TCP 连接(三次握手) 如果是 HTTPS,还需要进行 TLS 握手 发送 HTTP 请求\n浏览器构建 HTTP 请求报文 通过网络发送到服务器 浏览器渲染过程\n解析 HTML 构建 DOM 树(DOM Tree) 解析 CSS 构建 CSSOM(CSS Object Model) 合并 DOM 和 CSSOM 构建渲染树(Render Tree) 布局(Layout):计算每个节点的几何信息 绘制(Painting):将渲染树绘制到屏幕上 DNS (Domain Name System) 原理 DNS 是一个分布式数据库,主要功能是将域名转换为 IP 地址。解析过程如下:","title":"网络是如何连接的"},{"content":"内容分发网络 cdn Content Delivery Network cache-control\n","permalink":"https://huing.github.io/posts/%E4%BA%92%E8%81%94%E7%BD%91/cdn%E5%8E%9F%E7%90%86/","summary":"内容分发网络 cdn Content Delivery Network cache-control","title":"CDN原理"},{"content":"文件读写 fs\n路径查找 path\n网络 http\n包管理 npm yarn npx pnpm package.json 配置 入口文件字段 main: CommonJS 规范的入口文件\nNode.js 默认使用的入口点 通常指向 dist/index.js 或 lib/index.js 使用 require() 导入时使用此入口 type 的两个类型\nmodule: ES Module 规范的入口文件\n现代打包工具（webpack、rollup 等）优先使用 通常指向 .mjs 或含 ES modules 的 .js 文件 使用 import 语句导入时使用此入口 支持 tree-shaking umd: Universal Module Definition 入口文件\n兼容 AMD、CommonJS 和全局变量方式 适用于浏览器直接通过 \u0026lt;script\u0026gt; 标签引用 通常指向打包后的单一文件，如 dist/index.umd.js 主要区别说明：\nmain 是最传统的 CommonJS 格式入口，主要用于 Node.js 环境。 module 是现代 ES Module 格式入口，支持静态导入导出，便于打包工具进行 tree-shaking 优化。 umd 是通用格式，主要用于浏览器环境，可以同时支持多种模块系统。 这三种格式的存在使得同一个包可以在不同环境下都能正常使用，开发者可以根据具体使用场景选择最适合的版本。\nnpm 命令 login\nnpm login change version\nnpm version 1.0.0-beta.0 publish\nnpm publish --tag beta use\nnpm install — save libraryname@beta.num ","permalink":"https://huing.github.io/posts/nodejs/","summary":"文件读写 fs\n路径查找 path\n网络 http\n包管理 npm yarn npx pnpm package.json 配置 入口文件字段 main: CommonJS 规范的入口文件\nNode.js 默认使用的入口点 通常指向 dist/index.js 或 lib/index.js 使用 require() 导入时使用此入口 type 的两个类型\nmodule: ES Module 规范的入口文件\n现代打包工具（webpack、rollup 等）优先使用 通常指向 .mjs 或含 ES modules 的 .js 文件 使用 import 语句导入时使用此入口 支持 tree-shaking umd: Universal Module Definition 入口文件\n兼容 AMD、CommonJS 和全局变量方式 适用于浏览器直接通过 \u0026lt;script\u0026gt; 标签引用 通常指向打包后的单一文件，如 dist/index.umd.js 主要区别说明：\nmain 是最传统的 CommonJS 格式入口，主要用于 Node.js 环境。 module 是现代 ES Module 格式入口，支持静态导入导出，便于打包工具进行 tree-shaking 优化。 umd 是通用格式，主要用于浏览器环境，可以同时支持多种模块系统。 这三种格式的存在使得同一个包可以在不同环境下都能正常使用，开发者可以根据具体使用场景选择最适合的版本。","title":"npm命令"},{"content":"精确匹配 id SELECT * FROM menu WHERE id = 569; 模糊匹配 SELECT * FROM menu WHERE path LIKE \u0026#39;%teacher%\u0026#39;; 定义变量 SET @path = \u0026#39;teacher\u0026#39;; SELECT * FROM menu WHERE path LIKE CONCAT(\u0026#39;%\u0026#39;, @path, \u0026#39;%\u0026#39;); 连表查询 SELECT a.id,a.NAME,b.num FROM classes a LEFT JOIN classes_detail b ON a.id=b.id WHERE a.id=2541; IS NULL SELECT * FROM classes WHERE person_avg IS NULL; 把查询到的结果插入表中 INSERT INTO menu SELECT * FROM menu_copy WHERE is_deleted = 0 GROUP BY name; 找到所有的菜单并插入菜单表 INSERT INTO menu ( SELECT*FROM menu_copy WHERE parent_id=0 AND is_deleted=0 UNION ALL SELECT*FROM menu_copy WHERE parent_id\u0026lt;\u0026gt; 0 AND is_deleted=0 GROUP BY NAME); 删除 name = 监控中心 并且 id != 389 DELETE FROM menu WHERE name = \u0026#39;监控中心\u0026#39; AND id \u0026lt;\u0026gt; 389; 删除多条数据 DELETE FROM menu WHERE id IN ( SELECT id FROM ( SELECT id FROM menu WHERE NAME=\u0026#39;大区管理\u0026#39; AND id\u0026lt;\u0026gt; 391) AS t); 更新多条数据 UPDATE menu SET parent_id=391 WHERE parent_id IN ( SELECT id FROM ( SELECT id FROM menu WHERE name=\u0026#39;大区管理\u0026#39; AND id\u0026lt;\u0026gt; 391) AS t); ","permalink":"https://huing.github.io/posts/sql%E8%AF%AD%E6%B3%95/","summary":"精确匹配 id SELECT * FROM menu WHERE id = 569; 模糊匹配 SELECT * FROM menu WHERE path LIKE \u0026#39;%teacher%\u0026#39;; 定义变量 SET @path = \u0026#39;teacher\u0026#39;; SELECT * FROM menu WHERE path LIKE CONCAT(\u0026#39;%\u0026#39;, @path, \u0026#39;%\u0026#39;); 连表查询 SELECT a.id,a.NAME,b.num FROM classes a LEFT JOIN classes_detail b ON a.id=b.id WHERE a.id=2541; IS NULL SELECT * FROM classes WHERE person_avg IS NULL; 把查询到的结果插入表中 INSERT INTO menu SELECT * FROM menu_copy WHERE is_deleted = 0 GROUP BY name; 找到所有的菜单并插入菜单表 INSERT INTO menu ( SELECT*FROM menu_copy WHERE parent_id=0 AND is_deleted=0 UNION ALL SELECT*FROM menu_copy WHERE parent_id\u0026lt;\u0026gt; 0 AND is_deleted=0 GROUP BY NAME); 删除 name = 监控中心 并且 id !","title":"Sql语法"},{"content":"有利 seo\n方便其他设备解析\n便于维护提高可读性\nsection, article, main, p,\ntime,\ntitle,header,nav,\naside, footer,\nWebAssembly: WebAssembly 是一种新的编码方式，可以在现代的 Web 浏览器中运行——它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C/C++、C# 和 Rust 等语言提供编译目标，以便它们可以在 Web 上运行\n","permalink":"https://huing.github.io/posts/html/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/","summary":"有利 seo\n方便其他设备解析\n便于维护提高可读性\nsection, article, main, p,\ntime,\ntitle,header,nav,\naside, footer,\nWebAssembly: WebAssembly 是一种新的编码方式，可以在现代的 Web 浏览器中运行——它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C/C++、C# 和 Rust 等语言提供编译目标，以便它们可以在 Web 上运行","title":"语义化标签"},{"content":"Map 类型 Map // ✅ Initialize Map from Array // 👇️ const map1: Map\u0026lt;string, string\u0026gt; const map1: Map\u0026lt;string, string\u0026gt; = new Map([ [\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;], [\u0026#34;country\u0026#34;, \u0026#34;Chile\u0026#34;], ]); // 👇️ {\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Tom\u0026#39;, \u0026#39;country\u0026#39; =\u0026gt; \u0026#39;Chile\u0026#39;} console.log(map1); // ✅ Initialize Map from Object const obj = { name: \u0026#34;Tom\u0026#34;, country: \u0026#34;Chile\u0026#34; }; const map2 = new Map\u0026lt;string, string\u0026gt;(Object.entries(obj)); // 👇️ {\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Tom\u0026#39;, \u0026#39;country\u0026#39; =\u0026gt; \u0026#39;Chile\u0026#39;} console.log(map2); objects vs maps 意外的键\nmap: 显式插入的 object: 原型链上的键名 键的类型\nmap: 任意值，包括函数、对象或任意基本类型 object: 必须是一个 String 或是 Symbol 在 JavaScript 中创建不可修改的对象方法 在 JavaScript 中，有几种方法可以创建不可修改的对象方法：\n1. 使用 Object.defineProperty() 或 Object.defineProperties() const obj = {}; Object.defineProperty(obj, \u0026#34;immutableMethod\u0026#34;, { value: function () { return \u0026#34;I can\u0026#39;t be changed\u0026#34;; }, writable: false, // 不可写 configurable: false, // 不可配置 }); // 尝试修改会静默失败（严格模式下会报错） obj.immutableMethod = function () { return \u0026#34;new function\u0026#34;; }; console.log(obj.immutableMethod()); // 仍然输出 \u0026#34;I can\u0026#39;t be changed\u0026#34; 2. 使用 Object.freeze() const obj = { immutableMethod() { return \u0026#34;I can\u0026#39;t be changed\u0026#34;; }, }; Object.freeze(obj); // 冻结整个对象 // 尝试修改会静默失败（严格模式下会报错） obj.immutableMethod = function () { return \u0026#34;new function\u0026#34;; }; console.log(obj.immutableMethod()); // 仍然输出原始方法 // Object.freeze() 是浅冻结，嵌套对象仍然可以被修改 3. 使用 ES6 的 Proxy const obj = { immutableMethod() { return \u0026#34;I can\u0026#39;t be changed\u0026#34;; }, }; const protectedObj = new Proxy(obj, { set(target, prop, value) { if (prop === \u0026#34;immutableMethod\u0026#34;) { throw new Error(`Cannot modify ${prop} method`); } target[prop] = value; return true; }, }); // 尝试修改会抛出错误 protectedObj.immutableMethod = function () { return \u0026#34;new function\u0026#34;; }; // Error 4. 使用类中的 getter 和闭包 class ImmutableClass { constructor() { const immutableMethod = () =\u0026gt; \u0026#34;I can\u0026#39;t be changed\u0026#34;; Object.defineProperty(this, \u0026#34;immutableMethod\u0026#34;, { get: () =\u0026gt; immutableMethod, configurable: false, }); } } const instance = new ImmutableClass(); instance.immutableMethod = function () { return \u0026#34;new function\u0026#34;; }; // 无效 手写一个 CloneDeep const cloneDeep = (obj) =\u0026gt; { // 处理基本类型和 null if (obj === null || typeof obj !== \u0026#34;object\u0026#34;) { return obj; } // 处理日期对象 if (obj instanceof Date) { return new Date(obj.getTime()); } // 处理正则表达式 if (obj instanceof RegExp) { return new RegExp(obj.source, obj.flags); } // 处理数组 if (Array.isArray(obj)) { return obj.map((item) =\u0026gt; cloneDeep(item)); } // 处理 Map if (obj instanceof Map) { const clonedMap = new Map(); obj.forEach((value, key) =\u0026gt; { clonedMap.set(cloneDeep(key), cloneDeep(value)); }); return clonedMap; } // 处理 Set if (obj instanceof Set) { const clonedSet = new Set(); obj.forEach((value) =\u0026gt; { clonedSet.add(cloneDeep(value)); }); return clonedSet; } // 处理循环引用 const weakMap = new WeakMap(); function deepClone(obj) { if (weakMap.has(obj)) { return weakMap.get(obj); } const cloned = Object.create(Object.getPrototypeOf(obj)); weakMap.set(obj, cloned); // 获取所有属性，包括不可枚举的属性 const descriptors = Object.getOwnPropertyDescriptors(obj); // 复制所有属性描述符 Object.defineProperties( cloned, Object.fromEntries( Object.entries(descriptors).map(([key, descriptor]) =\u0026gt; [ key, { ...descriptor, value: descriptor.value \u0026amp;\u0026amp; typeof descriptor.value === \u0026#34;object\u0026#34; ? cloneDeep(descriptor.value) : descriptor.value, }, ]) ) ); return cloned; } return deepClone(obj); }; // 使用示例 const example = { string: \u0026#34;Hello\u0026#34;, number: 123, boolean: true, null: null, undefined: undefined, date: new Date(), regexp: /test/gi, array: [1, 2, { a: 3 }], map: new Map([[\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;]]), set: new Set([1, 2, 3]), nested: { a: 1, b: { c: 2, }, }, }; // 创建循环引用 example.self = example; const cloned = cloneDeep(example); ","permalink":"https://huing.github.io/posts/javascript/%E5%AF%B9%E8%B1%A1/","summary":"Map 类型 Map // ✅ Initialize Map from Array // 👇️ const map1: Map\u0026lt;string, string\u0026gt; const map1: Map\u0026lt;string, string\u0026gt; = new Map([ [\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;], [\u0026#34;country\u0026#34;, \u0026#34;Chile\u0026#34;], ]); // 👇️ {\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Tom\u0026#39;, \u0026#39;country\u0026#39; =\u0026gt; \u0026#39;Chile\u0026#39;} console.log(map1); // ✅ Initialize Map from Object const obj = { name: \u0026#34;Tom\u0026#34;, country: \u0026#34;Chile\u0026#34; }; const map2 = new Map\u0026lt;string, string\u0026gt;(Object.entries(obj)); // 👇️ {\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Tom\u0026#39;, \u0026#39;country\u0026#39; =\u0026gt; \u0026#39;Chile\u0026#39;} console.log(map2); objects vs maps 意外的键","title":"对象"},{"content":"export const themes = { light: { color: \u0026#34;#000000\u0026#34;, background: \u0026#34;#eeeeee\u0026#34;, }, dark: { color: \u0026#34;#ffffff\u0026#34;, background: \u0026#34;#222222\u0026#34;, }, }; export const ThemeContext = createContext({ theme: themes.dark, toggleTheme: () =\u0026gt; { // }, }); const Button = () =\u0026gt; { // 消费 consumers return ( \u0026lt;ThemeContext.Consumer\u0026gt; {({ theme, toggleTheme }) =\u0026gt; ( \u0026lt;button onClick={toggleTheme} style={{ background: theme.background, color: theme.color, width: 100, height: 60, }} \u0026gt; click \u0026lt;/button\u0026gt; )} \u0026lt;/ThemeContext.Consumer\u0026gt; ); }; const ThemedButton = () =\u0026gt; { return \u0026lt;Button /\u0026gt;; }; const App = () =\u0026gt; { const [theme, setTheme] = useState(themes.dark); const toggleTheme = () =\u0026gt; { setTheme(theme === themes.dark ? themes.light : themes.dark); }; return ( \u0026lt;ThemeContext.Provider value={{ theme, toggleTheme }}\u0026gt; \u0026lt;ThemedButton /\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); }; export default App; ","permalink":"https://huing.github.io/posts/react/consumer/","summary":"export const themes = { light: { color: \u0026#34;#000000\u0026#34;, background: \u0026#34;#eeeeee\u0026#34;, }, dark: { color: \u0026#34;#ffffff\u0026#34;, background: \u0026#34;#222222\u0026#34;, }, }; export const ThemeContext = createContext({ theme: themes.dark, toggleTheme: () =\u0026gt; { // }, }); const Button = () =\u0026gt; { // 消费 consumers return ( \u0026lt;ThemeContext.Consumer\u0026gt; {({ theme, toggleTheme }) =\u0026gt; ( \u0026lt;button onClick={toggleTheme} style={{ background: theme.background, color: theme.color, width: 100, height: 60, }} \u0026gt; click \u0026lt;/button\u0026gt; )} \u0026lt;/ThemeContext.Consumer\u0026gt; ); }; const ThemedButton = () =\u0026gt; { return \u0026lt;Button /\u0026gt;; }; const App = () =\u0026gt; { const [theme, setTheme] = useState(themes.","title":"Consumer"},{"content":"Ref 实现父组件调用子组件方法 ref 的值根据节点的类型而有所不同：\n当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。 你不能在函数组件上使用 ref 属性，因为他们没有实例。 构造组件 createRef 仅能用在 ClassComponent\nclass CustomInput extends React.Component { constructor(props) { super(props); // 为 DOM 元素添加 ref this.textInput = React.createRef(); this.doSomething = this.doSomething.bind(this); } doSomething() { // this.textInput.current.focus() } render() { return \u0026lt;input type=\u0026#34;text\u0026#34; ref={this.textInput} /\u0026gt;; } } class ParentInput extends React.Component { constructor(props) { super(props); // 为 class 组件添加 Ref this.textInput = React.createRef(); } componentDidMount() { // this.textInput.current.doSomething() console.log(this.textInput.current); } render() { return \u0026lt;CustomInput ref={this.textInput} /\u0026gt;; } } 函数组件 useRef 仅能用在 FunctionComponent\nfunction FancyInput(props, ref) { const inputRef = useRef(); // 使用 ref 时自定义暴露给父组件的实例值 useImperativeHandle(ref, () =\u0026gt; ({ focus: () =\u0026gt; { inputRef.current.focus(); }, doSomething: () =\u0026gt; { console.log(\u0026#34;doSomething\u0026#34;); }, })); return \u0026lt;input ref={inputRef} /\u0026gt;; } // forwardRef 会创建一个React组件 const ChildInput = forwardRef(FancyInput); function ParentInput() { const inputRef = useRef(); useEffect(() =\u0026gt; { console.log(inputRef.current); }, [inputRef.current]); return \u0026lt;ChildInput ref={inputRef} /\u0026gt;; } 子组件调用父组件方法 function ChildButton(props) { return \u0026lt;button onClick={props.doSomething}\u0026gt;点击\u0026lt;/button\u0026gt;; } function ParentButton() { const doSomething = () =\u0026gt; { console.log(\u0026#34;doSomething\u0026#34;); }; return \u0026lt;ChildButton doSomething={doSomething} /\u0026gt;; } export default ParentButton; ","permalink":"https://huing.github.io/posts/react/ref%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","summary":"Ref 实现父组件调用子组件方法 ref 的值根据节点的类型而有所不同：\n当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。 你不能在函数组件上使用 ref 属性，因为他们没有实例。 构造组件 createRef 仅能用在 ClassComponent\nclass CustomInput extends React.Component { constructor(props) { super(props); // 为 DOM 元素添加 ref this.textInput = React.createRef(); this.doSomething = this.doSomething.bind(this); } doSomething() { // this.textInput.current.focus() } render() { return \u0026lt;input type=\u0026#34;text\u0026#34; ref={this.textInput} /\u0026gt;; } } class ParentInput extends React.Component { constructor(props) { super(props); // 为 class 组件添加 Ref this.","title":"Ref实现父组件调用子组件方法"},{"content":"promise 实现 class Commitment { static PENDING = \u0026#34;待定\u0026#34;; static FULFILLED = \u0026#34;成功\u0026#34;; static REJECTED = \u0026#34;拒绝\u0026#34;; private status: \u0026#34;PENDING\u0026#34; | \u0026#34;FULFILLED\u0026#34; | \u0026#34;REJECTED\u0026#34;; private result: any; constructor(func: (resolve: (value: any) =\u0026gt; void, reject: (reason?: any) =\u0026gt; void) =\u0026gt; void) { this.status = \u0026#34;PENDING\u0026#34;; this.result = undefined; try { func(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value: any) { if (this.status === \u0026#34;PENDING\u0026#34;) { this.status = \u0026#34;FULFILLED\u0026#34;; this.result = value; } } reject(reason?: any) { if (this.status === \u0026#34;PENDING\u0026#34;) { this.status = \u0026#34;REJECTED\u0026#34;; this.result = reason; } } then(onfulfilled?: (value: any) =\u0026gt; void, onrejected?: (reason: any) =\u0026gt; void) { return new Commitment((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { let res: any; if (this.status === \u0026#34;FULFILLED\u0026#34; \u0026amp;\u0026amp; onfulfilled) { res = onfulfilled(this.result); } if (this.status === \u0026#34;REJECTED\u0026#34; \u0026amp;\u0026amp; onrejected) { res = onrejected(this.result); } if (this.status === \u0026#34;FULFILLED\u0026#34; \u0026amp;\u0026amp; resolve) { resolve(res); } if (this.status === \u0026#34;REJECTED\u0026#34; \u0026amp;\u0026amp; reject) { reject(res); } }); }); } } 实现一个 myPromiseAll function myPromiseAll(promises) { if (typeof promises[Symbol.iterator] !== \u0026#34;function\u0026#34;) { return Promise.reject(new TypeError(\u0026#34;arguments must be an iterator\u0026#34;)); } if (!Array.isArray(promises)) { return Promise.reject(new TypeError(\u0026#34;arguments must be an array\u0026#34;)); } if (promises.length === 0) { return Promise.resolve([]); } return new Promise((resolve, reject) =\u0026gt; { let count = 0; let result = []; for (let i = 0; i \u0026lt; promises.length; i++) { Promise.resolve(promises[i]) .then((val) =\u0026gt; { count++; result[i] = val; if (count === promises.length) { resolve(result); } }) .catch((err) =\u0026gt; { reject(err); }); } }); } promise 执行顺序 console.log(\u0026#34;同步任务1\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;宏任务: setTimeout 1\u0026#34;); }, 0); Promise.resolve() .then(() =\u0026gt; { console.log(\u0026#34;微任务: Promise1\u0026#34;); return Promise.resolve(); }) .then(() =\u0026gt; { console.log(\u0026#34;微任务: Promise2\u0026#34;); }); queueMicrotask(() =\u0026gt; { console.log(\u0026#34;微任务: queueMicrotask\u0026#34;); }); setTimeout(() =\u0026gt; { console.log(\u0026#34;宏任务: setTimeout 2\u0026#34;); }, 0); console.log(\u0026#34;同步任务2\u0026#34;); setImmediate?.(() =\u0026gt; { console.log(\u0026#34;宏任务: setImmediate\u0026#34;); }); process.nextTick(() =\u0026gt; { console.log(\u0026#34;微任务: process.nextTick\u0026#34;); }); console.log(\u0026#34;1. 同步代码开始\u0026#34;); // 宏任务1 setTimeout(() =\u0026gt; { console.log(\u0026#34;8. setTimeout 回调 (宏任务1)\u0026#34;); // 在宏任务1中添加微任务 Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;9. 宏任务1中的微任务\u0026#34;); // 在微任务中添加新的微任务 queueMicrotask(() =\u0026gt; { console.log(\u0026#34;10. 宏任务1中的微任务的微任务\u0026#34;); }); }); }, 0); // 宏任务2 setTimeout(() =\u0026gt; { console.log(\u0026#34;11. setTimeout 回调 (宏任务2)\u0026#34;); }, 0); // 微任务1 Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;4. Promise 回调 (微任务1)\u0026#34;); // 在微任务1中添加新的微任务 queueMicrotask(() =\u0026gt; { console.log(\u0026#34;6. 微任务1中的微任务\u0026#34;); // 在嵌套微任务中添加宏任务 setTimeout(() =\u0026gt; { console.log(\u0026#34;12. 嵌套微任务中添加的宏任务\u0026#34;); }, 0); }); }); console.log(\u0026#34;2. 同步代码继续\u0026#34;); // 微任务2 queueMicrotask(() =\u0026gt; { console.log(\u0026#34;5. queueMicrotask 回调 (微任务2)\u0026#34;); }); // 微任务3 Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;7. Promise 回调 (微任务3)\u0026#34;); }); console.log(\u0026#34;3. 同步代码结束\u0026#34;); ","permalink":"https://huing.github.io/posts/javascript/promise%E5%AE%9E%E7%8E%B0/","summary":"promise 实现 class Commitment { static PENDING = \u0026#34;待定\u0026#34;; static FULFILLED = \u0026#34;成功\u0026#34;; static REJECTED = \u0026#34;拒绝\u0026#34;; private status: \u0026#34;PENDING\u0026#34; | \u0026#34;FULFILLED\u0026#34; | \u0026#34;REJECTED\u0026#34;; private result: any; constructor(func: (resolve: (value: any) =\u0026gt; void, reject: (reason?: any) =\u0026gt; void) =\u0026gt; void) { this.status = \u0026#34;PENDING\u0026#34;; this.result = undefined; try { func(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value: any) { if (this.status === \u0026#34;PENDING\u0026#34;) { this.status = \u0026#34;FULFILLED\u0026#34;; this.result = value; } } reject(reason?","title":"Promise实现"},{"content":"基于原型链的继承 继承属性 // 让我们从一个函数里创建一个对象 o，它自身拥有属性 a 和 b 的： let f = function () { this.a = 1; this.b = 2; }; /_这么写也一样 function f() { this.a = 1; this.b = 2; } _/ let o = new f(); // {a: 1, b: 2}\n// 在 f 函数的原型上定义属性 f.prototype.b = 3; f.prototype.c = 4;\n// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链 // 综上，整个原型链如下： // {a:1, b:2} \u0026mdash;\u0026gt; {b:3, c:4} \u0026mdash;\u0026gt; Object.prototype\u0026mdash;\u0026gt; null\nconsole.log(o.a); // 1 // a 是 o 的自身属性吗？是的，该属性的值为 1\nconsole.log(o.b); // 2 // b 是 o 的自身属性吗？是的，该属性的值为 2 // 原型上也有一个\u0026rsquo;b\u0026rsquo;属性，但是它不会被访问到。 // 这种情况被称为\u0026quot;属性遮蔽 (property shadowing)\u0026quot;\nconsole.log(o.c); // 4 // c 是 o 的自身属性吗？不是，那看看它的原型上有没有 // c 是 o.[[Prototype]] 的属性吗？是的，该属性的值为 4\nconsole.log(o.d); // undefined // d 是 o 的自身属性吗？不是，那看看它的原型上有没有 // d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有 // o.[[Prototype]].[[Prototype]] 为 null，停止搜索 // 找不到 d 属性，返回 undefined\n继承方法 var o = { a: 2, m: function () { return this.a + 1; }, };\nconsole.log(o.m()); // 3 // 当调用 o.m 时，\u0026rsquo;this\u0026rsquo; 指向了 o.\nvar p = Object.create(o); // p 是一个继承自 o 的对象\np.a = 4; // 创建 p 的自身属性 \u0026lsquo;a\u0026rsquo; console.log(p.m()); // 5 // 调用 p.m 时，\u0026rsquo;this\u0026rsquo; 指向了 p // 又因为 p 继承了 o 的 m 函数 // 所以，此时的 \u0026rsquo;this.a\u0026rsquo; 即 p.a，就是 p 的自身属性 \u0026lsquo;a\u0026rsquo; console.log(o.m()); // 3\n","permalink":"https://huing.github.io/posts/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%90%86%E8%A7%A3/","summary":"基于原型链的继承 继承属性 // 让我们从一个函数里创建一个对象 o，它自身拥有属性 a 和 b 的： let f = function () { this.a = 1; this.b = 2; }; /_这么写也一样 function f() { this.a = 1; this.b = 2; } _/ let o = new f(); // {a: 1, b: 2}\n// 在 f 函数的原型上定义属性 f.prototype.b = 3; f.prototype.c = 4;\n// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链 // 综上，整个原型链如下： // {a:1, b:2} \u0026mdash;\u0026gt; {b:3, c:4} \u0026mdash;\u0026gt; Object.","title":"原型链理解"},{"content":"Array 方法 修改器方法 改变自身的值 push() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度 pop() 从一个数组中删除并返回删除的元素值 reverse() 颠倒数组中的元素，并返回该数组的引用，同时改变原数组 const sourceArray = [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]; const reverseArray = sourceArray.reverse(); sourceArray === reverseArray; // true shift() 删除数组第一个元素，并返回删除的元素值 sort() splice() 删除或新增元素，返回修改后的数组，改变原数组 unshift() 添加元素到数组的头部 返回 length 属性值 访问方法 返回新数组 concat() 将数组和/或值连接成新数组，对于对象引用的值修改会修改原数组 const arr = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; const al = arr.concat(1, [2, 3]); console.log(al); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, 1, 2, 3] includes() join() slice() [begin, end) 对于对象引用的值修改会修改原数组 toString() {}.toString() // 报错 没有原型链了吧 [].toString() // \u0026#34;\u0026#34; toLocaleString() indexOf() lastIndexOf() 迭代方法 forEach()不会改变原数组。除了抛出异常以外，没有办法中止或跳出 forEach() 循环。 entries() every() some() filter() 返回一个新数组 find() findIndex() keys() map() 返回一个新数组 [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;10\u0026#34;].map(parseInt); // [1, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, 9] reduce() reduceRight() values() 属性 Array.prototype.constructor Array.prototype.length 生成数组方法 Array.from() Array.from(\u0026#34;foo\u0026#34;); // [\u0026#34;f\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;o\u0026#34;]; Array.from([1, 2, 3], (x) =\u0026gt; x + x); // [2, 4, 6]; Array.of() Array.of(1, 2, 3); // [1, 2, 3] Array.of(undefined); // [undefined] Array.apply const arr = Array.apply(null, new Array(4)); arr.map((elem, index) =\u0026gt; index); // [0, 1, 2, 3] 判断变量是否为数组 Array.isArray(arr); // true arr.__proto__ === Array.prototype; // true arr instanceof Array; // true Object.prototype.toString.call(arr); // \u0026#34;[object Array]\u0026#34; ","permalink":"https://huing.github.io/posts/javascript/array/","summary":"Array 方法 修改器方法 改变自身的值 push() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度 pop() 从一个数组中删除并返回删除的元素值 reverse() 颠倒数组中的元素，并返回该数组的引用，同时改变原数组 const sourceArray = [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]; const reverseArray = sourceArray.reverse(); sourceArray === reverseArray; // true shift() 删除数组第一个元素，并返回删除的元素值 sort() splice() 删除或新增元素，返回修改后的数组，改变原数组 unshift() 添加元素到数组的头部 返回 length 属性值 访问方法 返回新数组 concat() 将数组和/或值连接成新数组，对于对象引用的值修改会修改原数组 const arr = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; const al = arr.concat(1, [2, 3]); console.log(al); // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, 1, 2, 3] includes() join() slice() [begin, end) 对于对象引用的值修改会修改原数组 toString() {}.toString() // 报错 没有原型链了吧 [].","title":"Array"},{"content":"浅拷贝方法 slice() Object.assign({}, a) ...rest 获取浏览器信息 navigator navigator.userAgent; // \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\u0026#34; navigator.language; // \u0026#34;zh-CN\u0026#34; navigator.languages; // [\u0026#34;zh-CN\u0026#34;, \u0026#34;zh\u0026#34;, \u0026#34;fr-CA\u0026#34;, \u0026#34;fr\u0026#34;, \u0026#34;fr-CH\u0026#34;, \u0026#34;fr-FR\u0026#34;, \u0026#34;en\u0026#34;] setTimeOut 实际延时比设定值更久的原因 最小延迟时间 时间误差 函数嵌套延迟 4ms 回调函数阻塞导致函数 setTimeout 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。 字面量 Literals 数组字面量 Array literals\nvar fish = [\u0026#34;Lion\u0026#34;, , \u0026#34;Angel\u0026#34;]; // fish[1] = undefined 布尔字面量 Boobean literals\n浮点数字面量 Floating-point literals\n整数 Integers\n对象字面量 Object literals\nRegExp literals\n字符串字面量 String literals\n模板字面量 Template literals\nBOM 浏览器对象模型 DOM 虚拟对象模型 parse stringify parse() 方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。 JSON.parse() 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象 JSON.stringify() 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串 console.log( new Date(), (new Date()).toString(), (new Date()).valueOf(), Date.now(), Date.parse(new Date()) ) Wed Aug 28 2019 14:35:22 GMT+0800 (中国标准时间) \u0026#34;Wed Aug 28 2019 14:35:22 GMT+0800 (中国标准时间)\u0026#34; 1566974122905 1566974122905 1566974122000 js 中 === vs == 严格相等 === 宽松相等 == Object.is(val1, val2) 父组件调用子组件方法，子组件向父组件传值方法 子组件向父组件传值方法 把子组件的值当成参数，传递到父组件的作用域 父组件调用子组件方法 propshttp://taobaofed.org/blog/2016/11/17/react-components-communication/ Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。 const {Provider, Consumer} = React.createContext(defaultValue) \u0026lt;Provider value={/* some value */}\u0026gt; \u0026lt;Consumer\u0026gt; {value =\u0026gt; /* render something based on the context value */} \u0026lt;/Consumer\u0026gt; React 重复渲染 SVG 无答案 React 是什么，特点 用于构建用户界面的 JavaScript 库 声明式设计 −React 采用声明范式，可以轻松描述应用。 高效 −React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。 灵活 −React 可以与已知的库或框架很好地配合。 JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 前端工程化 无解 虚拟 DOM 首先说说为什么要使用 Virturl DOM，因为操作真实 DOM 的耗费的性能代价太高，所以 react 内部使用 js 实现了一套 dom 结构，在每次操作在和真实 dom 之前，使用实现好的 diff 算法，对虚拟 dom 进行比较，递归找出有变化的 dom 节点，然后对其进行更新操作。为了实现虚拟 DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是 prop，每次进行 diff 的时候，react 会先比较该节点类型，假如节点类型不一样，那么 react 会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较 prop 是否有更新，假如有 prop 不一样，那么 react 会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点。 基于 diff 算法的同级对比，它主要分为四种类型的对比，分别为: 新建 create： 新的 vd 中有这个节点，旧的没有 删除 remove： 新的 vd 中没有这个节点，旧的有 替换 replace： 新的 vd 的 tagName 和旧的 tagName 不同 更新 update： 除了上面三点外的不同，具体是比较 attributes 先，然后再比较 children 为什么要写 super(props) 为什么要写 jsx 为什么要打包 函数组件和 class 组件区别 new URL() this 指向 bind, apply, call 区别 const me = { a: 123 }; const he = { b: 456 }; function x() { console.log(this, arguments, this.a); } bind，返回函数的 copy 使用时要重新调用一次 参数形式， (this, arg1, arg2)\nx.bind(me, 2, 3).bind(he)(); // bind只生效一次！ // {a: 123} {\u0026#39;0\u0026#39;: 2,\u0026#39;1\u0026#39;: 3} 123 apply，返回函数的调用的结果 参数形式， (this, [arg1, arg2])\nx.apply(me, [2, 3]); // {a: 123} {\u0026#39;0\u0026#39;: 2,\u0026#39;1\u0026#39;: 3} 123 call，返回函数的调用的结果 参数形式， (this, arg1, arg2)\nx.call(me, 2, 3); // {a: 123} {\u0026#39;0\u0026#39;: 2,\u0026#39;1\u0026#39;: 3} 123 es6+ 变量提升 时间冒泡捕获 作用域 原型 闭包 闭包（Closure）是 JavaScript 中一个重要的概念，指的是一个函数可以访问其外部作用域中的变量，即使在该函数在其他作用域中被调用时也能保持对这些变量的访问权限。换句话说，闭包让你可以从内部函数访问外部函数的作用域。\n闭包的基本示例 function outer() { const message = \u0026#34;Hello\u0026#34;; function inner() { console.log(message); // 可以访问 outer 函数中的变量 } return inner; } const fn = outer(); fn(); // 输出: \u0026#34;Hello\u0026#34; 闭包的主要应用场景 数据私有化 function counter() { let count = 0; return { increment() { count++; return count; }, getCount() { return count; }, }; } const myCounter = counter(); console.log(myCounter.increment()); // 1 console.log(myCounter.increment()); // 2 console.log(myCounter.getCount()); // 2 函数工厂 function multiply(x) { return function (y) { return x * y; }; } const multiplyByTwo = multiply(2); console.log(multiplyByTwo(4)); // 8 模块化模式 const module = (function () { let privateVariable = 0; function privateMethod() { return privateVariable; } return { publicMethod: function () { privateVariable++; return privateMethod(); }, }; })(); 事件处理和回调 // 防抖：事件触发后延迟执行，若在延迟期间重复触发则重置延迟 function debounce(fn, delay) { let timer; return function (...args) { clearTimeout(timer); timer = setTimeout(() =\u0026gt; fn.apply(this, args), delay); }; } // 节流：事件触发后在一段时间内只执行一次 function throttle(fn, interval) { let lastTime = 0; return function (...args) { const now = Date.now(); if (now - lastTime \u0026gt;= interval) { fn.apply(this, args); lastTime = now; } }; } 柯里化（Currying） \u0026ndash; function.length\nconsole.log(Function.length); // 1 console.log((() =\u0026gt; {}).length); // 0 console.log(((a) =\u0026gt; {}).length); // 1 console.log(((a, b) =\u0026gt; {}).length); // 2，依此类推 console.log(((...args) =\u0026gt; {}).length); // 0，剩余参数不计算在内 console.log(((a, b = 1, c) =\u0026gt; {}).length); // 1，只计算第一个具有默认值的参数之前的参数 \u0026ndash; 实现\nfunction curry(fn) { return function curried(...args) { if (args.length \u0026gt;= fn.length) { return fn.apply(this, args); } return function (...moreArgs) { return curried.apply(this, args.concat(moreArgs)); }; }; } function add(a, b, c) { return a + b + c; } curry(add)(1)(2)(3); /* * 柯里化 相加 * */ function add(...argus) { // arguments是个对象 // let args = Array.prototype.slice.call(arguments); const args = argus; const inner = function (...innerArgs) { args.push(...innerArgs); return inner; }; inner.toString = function () { return args.reduce((acc, cur) =\u0026gt; acc + cur, 0); }; inner.value = function () { return args.reduce((acc, cur) =\u0026gt; acc + cur, 0); }; return inner; } // const result = add(1)(2)(3)(4)(5); const result = add(1, 2, 3, 4)(5); result.toString(); result.value(); 使用闭包需要注意的点 内存管理：闭包会保持对外部变量的引用，可能导致内存无法及时释放 this 指向：在闭包中使用 this 时需要特别注意其指向 性能考虑：过度使用闭包可能会影响性能 闭包是 JavaScript 中非常强大的特性，合理使用可以实现很多优雅的编程模式和解决方案。但同时也需要注意内存管理等问题，避免造成内存泄漏。\n普通函数 vs 箭头函数 const funA = () =\u0026gt; { // this 指向 funA 的调用 // 没有 arguments // 不能new // 没有原型链 }; function funB(params) { // this 指向 函数内部 // 有 arguments; } this 指向 var test = \u0026#34;王五\u0026#34;; const outerFun = () =\u0026gt; { this.test = \u0026#34;张三\u0026#34;; return () =\u0026gt; { console.log(this.test); }; }; var obj = { test: \u0026#34;李四\u0026#34;, innerFun: outerFun(), }; obj.innerFun(); var test = \u0026#34;王五\u0026#34;; function outFun() { this.test = \u0026#34;张三\u0026#34;; return function () { console.log(this.test); }; } var obj = { test: \u0026#34;李四\u0026#34;, inFun: outFun(), }; obj.inFun(); var test = \u0026#34;王五\u0026#34;; var obj = { test: \u0026#34;李四\u0026#34;, inFun() { console.log(this.test); }, }; obj.inFun(); var test = \u0026#34;王五\u0026#34;; var obj = { test: \u0026#34;李四\u0026#34;, inFun: () =\u0026gt; { console.log(this.test); }, }; obj.inFun(); let test = \u0026#34;王五\u0026#34;; let obj = { test: \u0026#34;李四\u0026#34;, inFun: () =\u0026gt; { console.log(this.test); }, }; obj.inFun(); ","permalink":"https://huing.github.io/posts/javascript/base/","summary":"浅拷贝方法 slice() Object.assign({}, a) ...rest 获取浏览器信息 navigator navigator.userAgent; // \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\u0026#34; navigator.language; // \u0026#34;zh-CN\u0026#34; navigator.languages; // [\u0026#34;zh-CN\u0026#34;, \u0026#34;zh\u0026#34;, \u0026#34;fr-CA\u0026#34;, \u0026#34;fr\u0026#34;, \u0026#34;fr-CH\u0026#34;, \u0026#34;fr-FR\u0026#34;, \u0026#34;en\u0026#34;] setTimeOut 实际延时比设定值更久的原因 最小延迟时间 时间误差 函数嵌套延迟 4ms 回调函数阻塞导致函数 setTimeout 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。 字面量 Literals 数组字面量 Array literals\nvar fish = [\u0026#34;Lion\u0026#34;, , \u0026#34;Angel\u0026#34;]; // fish[1] = undefined 布尔字面量 Boobean literals\n浮点数字面量 Floating-point literals\n整数 Integers\n对象字面量 Object literals","title":"Base"},{"content":"基本语法 \\w 匹配一个单字字符 = [A-Za-z0-9_]\n? 匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}\n如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符）\neg: /\\d+/.exec('abc123') 匹配 123\neg: /\\d+?/.exec('abc123') 匹配 1\n+ 匹配前面一个表达式 1 次或者多次。等价于 {1,}\n* 匹配前一个表达式 0 次或多次。等价于 {0,}\n[^abc] = [^a-c] 反向字符集\n(?:x) 把 x 作为一个整体\n$ 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。 例如，/t$/ 并不会匹配 \u0026ldquo;eater\u0026rdquo; 中的 \u0026rsquo;t\u0026rsquo;，但是会匹配 \u0026ldquo;eat\u0026rdquo; 中的 \u0026rsquo;t\u0026rsquo;。\nexec 返回 const myRe = /d(b+)d/g; const myArray = myRe.exec(\u0026#34;cdbbdbsbz\u0026#34;); [ \u0026#34;dbbd\u0026#34;, \u0026#34;bb\u0026#34;, index: 1, input: \u0026#34;cdbbdbsbz\u0026#34; ] // 匹配到的字符串和所有被记住的子字符串 克隆正则 const reFlags = /\\w*$/; function cloneRegExp(regexp) { // reFlags.constructor === RegExp const result = new regexp.constructor(regexp.source, reFlags.exec(regexp)); result.lastIndex = regexp.lastIndex; return result; } cloneRegExp(/xyz/gim); // =\u0026gt; /xyz/gim 理解 // 匹配0次或多次，所以匹配空字符串 /\\w*/.exec(\u0026#39;/xyz/gim\u0026#39;) // [\u0026#39;\u0026#39;, index: 0, input: \u0026#39;/xyz/gim\u0026#39;, groups: undefined] // 匹配输入的结束，所以不会匹配xyz /\\w*$/.exec(\u0026#39;/xyz/gim\u0026#39;) // [\u0026#39;gim\u0026#39;, index: 5, input: \u0026#39;/xyz/gim\u0026#39;, groups: undefined] 手机号中间四位显示* // $n 代表第n个括号匹配的字符串 \u0026#34;11122223333\u0026#34;.replace(/(\\d{3})\\d{4}(\\d{4})/, \u0026#34;$1****$2\u0026#34;); 人名 let pattern = /\\s*;\\s*/; const names = \u0026#34;Orange Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand \u0026#34;; const nameList = names.split(pattern); console.log(\u0026#34;nameList\u0026#34;, nameList); pattern = /(\\w+)\\s+(\\w+)\\s*/; const bySurnameList = []; for (let i = 0, len = nameList.length; i \u0026lt; len; i++) { console.log(i, pattern.exec(nameList[i])); bySurnameList[i] = nameList[i].replace(pattern, \u0026#34;$2, $1\u0026#34;); } console.log(\u0026#34;bySurnameList\u0026#34;, bySurnameList); 字符串模板 function render(template, context) { // (.*?) 匹配字符最少次数 return template.replace( /\\{\\{(.*?)\\}\\}/g, (match, key) =\u0026gt; context[key.trim()] ); } const template = \u0026#34;{{name}}很厉害,才{{age}}岁\u0026#34;; const context = { name: \u0026#34;bottle\u0026#34;, age: \u0026#34;15\u0026#34; }; render(template, context); function generateMessage(template, data) { return template.replace(/\\${(.*?)\\}/g, (match, key) =\u0026gt; data[key.trim()]); } const template1 = \u0026#34;亲爱的${username}，中秋大促~，送你一张${coupon}优惠券，你感兴趣的${sku1} 和${sku2} 都能用！\u0026#34;; const data = { username: \u0026#34;桔子\u0026#34;, coupon: \u0026#34;5元\u0026#34;, sku1: \u0026#34;冰激凌\u0026#34;, sku2: \u0026#34;蛋糕\u0026#34;, }; generateMessage(template1, data); ","permalink":"https://huing.github.io/posts/javascript/clone%E6%AD%A3%E5%88%99/","summary":"基本语法 \\w 匹配一个单字字符 = [A-Za-z0-9_]\n? 匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}\n如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符）\neg: /\\d+/.exec('abc123') 匹配 123\neg: /\\d+?/.exec('abc123') 匹配 1\n+ 匹配前面一个表达式 1 次或者多次。等价于 {1,}\n* 匹配前一个表达式 0 次或多次。等价于 {0,}\n[^abc] = [^a-c] 反向字符集\n(?:x) 把 x 作为一个整体\n$ 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。 例如，/t$/ 并不会匹配 \u0026ldquo;eater\u0026rdquo; 中的 \u0026rsquo;t\u0026rsquo;，但是会匹配 \u0026ldquo;eat\u0026rdquo; 中的 \u0026rsquo;t\u0026rsquo;。\nexec 返回 const myRe = /d(b+)d/g; const myArray = myRe.exec(\u0026#34;cdbbdbsbz\u0026#34;); [ \u0026#34;dbbd\u0026#34;, \u0026#34;bb\u0026#34;, index: 1, input: \u0026#34;cdbbdbsbz\u0026#34; ] // 匹配到的字符串和所有被记住的子字符串 克隆正则 const reFlags = /\\w*$/; function cloneRegExp(regexp) { // reFlags.","title":"Clone正则"},{"content":"静态生成 构建时 （build time） 生成 html\n在每个页面请求时重用\n可以被 cdn 缓存\n服务器端渲染 在地址栏输入 url，发送 get 请求，生成 html\n页面内容会随着每个请求变化\ncdn 无法缓存\n","permalink":"https://huing.github.io/posts/nextjs%E9%A2%84%E6%B8%B2%E6%9F%93%E7%90%86%E8%A7%A3/","summary":"静态生成 构建时 （build time） 生成 html\n在每个页面请求时重用\n可以被 cdn 缓存\n服务器端渲染 在地址栏输入 url，发送 get 请求，生成 html\n页面内容会随着每个请求变化\ncdn 无法缓存","title":"nextjs预渲染理解"},{"content":" 原文地址 https://blog.logrocket.com/usestate-vs-useref/\nuseHooks 实现 https://usehooks.com/\nuseRef\nconst inputRef = useRef(); useState\nconst [count, setCount] = useState(0); let variable\nlet prevCount; useState 返回数组，第一个真实的状态(the actual state)，第二个状态更新函数(the state updater function) 状态更新组件重新渲染 (Every state change re-renders the App component),子组件也会触发更新 useRef 返回对象，包含属性 current,存真实的值，值更新不会触发组件更新 let 定义的变量在每次 render 时被覆盖，最终只有初始值 总结：\n在渲染周期（render cycles）和 ui 更新（UI updates）期间 两者都保存更新的值，useState 重新渲染 useRef 的 current 属性是可变的，useState 的 state 需要 setState 更新赋值 两者都被认为是数据 hook,useRef 可以直接访问 react 组件或者 dom 元素 ","permalink":"https://huing.github.io/posts/react/useref-vs-usestate/","summary":" 原文地址 https://blog.logrocket.com/usestate-vs-useref/\nuseHooks 实现 https://usehooks.com/\nuseRef\nconst inputRef = useRef(); useState\nconst [count, setCount] = useState(0); let variable\nlet prevCount; useState 返回数组，第一个真实的状态(the actual state)，第二个状态更新函数(the state updater function) 状态更新组件重新渲染 (Every state change re-renders the App component),子组件也会触发更新 useRef 返回对象，包含属性 current,存真实的值，值更新不会触发组件更新 let 定义的变量在每次 render 时被覆盖，最终只有初始值 总结：\n在渲染周期（render cycles）和 ui 更新（UI updates）期间 两者都保存更新的值，useState 重新渲染 useRef 的 current 属性是可变的，useState 的 state 需要 setState 更新赋值 两者都被认为是数据 hook,useRef 可以直接访问 react 组件或者 dom 元素 ","title":"useRef vs useState"},{"content":"iterm 左右切换 command + 左右键 new tab command + t close tab command + w 分屏左右切换 command + option + 左右键 分屏新建标签页 command + d 关闭 iterm command + q chrome 打开无痕模式 incognito command + shift + n 关闭标签页 command + w 切换标签页 command + option + 左右键 vscode 打开外部终端 shift + command + c 切换当前文件 command + option + 左右键 退出当前编辑器 command + w 向上下重设终端大小 control + command + 上下键 快捷键 切换窗口 control + 左右键 切换 app command + tab 四指拖动 四指聚拢 显示或隐藏聚焦 command + 空格 在访达窗口聚焦 command + option + 空格 [man 命令的名称] 可以查看命令的详细用法\nman htop man ls cp -r dir1/ dir2 移动文件\nmv file.jpg file2.jpg 重命名\nmvdir dir1 dir2 移动或重命名一个目录\ncd filename 转到目录\npwd 显示当前路径\nmkdir dirname 创建一个目录\nrm -r dir 删除目录 dircmp dir1 dir2 比较两个目录的内容\ntouch src/index.js 创建空文件或更新已存在文件时间\nrm file.txt 删除文件\n显示文件内容\ncat file.txt 编辑文件\nvi file.txt 解压缩\n压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查　询：tar -jtv -f filename.tar.bz2 解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 本地移动文件或文件夹\nmv ~/Downloads/MyFile.txt ~/Documents/Work/NewFileName.txt 本地拷贝文件或文件夹\ncp -R ~/Documents/Expenses /Volumes/Data/Expenses 创建压缩 tar 归档\n这里的v可以查看进程，可以不带 tar -czvf LotsOfFiles.tgz LotsOfFiles 解压缩 tar 归档\ntar -xvf LotsOfFiles.tgz 解压缩 xmind\ntar -xvf test.xmind -C /Users/huing/code/blog/convertToMd/zip 查看进程\nps -ef|grep nginx 找到占用的端口\nlsof -i:8082 kill (-9) pid 创建软连接\nln -s /usr/local/nodejs/bin/node /usr/local/bin ln -s /usr/local/nodejs/bin/npm /usr/local/bin ls\nls 仅列出当前目录可见文件 ls -l 列出当前目录可见文件详细信息 ls -hl 列出详细信息并以可读大小显示文件大小 ls -al 列出所有文件（包括隐藏）的详细信息 查看全局 yarn link 列表\nls -la ~/.config/yarn/link/ 查看当前项目 yarn link 列表\nls -l node_modules | grep ^l 取消链接\nyarn unlink ","permalink":"https://huing.github.io/posts/%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/","summary":"iterm 左右切换 command + 左右键 new tab command + t close tab command + w 分屏左右切换 command + option + 左右键 分屏新建标签页 command + d 关闭 iterm command + q chrome 打开无痕模式 incognito command + shift + n 关闭标签页 command + w 切换标签页 command + option + 左右键 vscode 打开外部终端 shift + command + c 切换当前文件 command + option + 左右键 退出当前编辑器 command + w 向上下重设终端大小 control + command + 上下键 快捷键 切换窗口 control + 左右键 切换 app command + tab 四指拖动 四指聚拢 显示或隐藏聚焦 command + 空格 在访达窗口聚焦 command + option + 空格 [man 命令的名称] 可以查看命令的详细用法","title":"快捷键\u0026终端命令"},{"content":"js 8 种数据类型 undefined null string number boolean symbol bigint object array function regexp date 数据类型判断方法 typeof 可以判断值类型，函数 typeof 0; // number typeof \u0026#34;ss\u0026#34;; // string typeof undefined; // undefined typeof true; // boolean typeof 2n; // bigint es6新增数据类型 typeof Symbol(\u0026#34;a\u0026#34;); // symbol es6新增数据类型 typeof function () {}; // function typeof null; // object 被认为是对象的占位符,但从技术上来说，它仍然是原始值 typeof []; // object typeof {}; // object instanceof 能判断对象类型 [] instanceof Array; //true [] instanceof Object; // true [].constructor == Array; //true [].constructor === Object; // false class People {} class Student extends People {} const vortesnail = new Student(); vortesnail instanceof People; // true vortesnail instanceof Student; // true vortesnail 作为实例，顺着原型链能找到 Student.prototype 及 People.prototype，所以都为 true。\nObject.prototype.toString.call() 既能判断基本类型也能判断对象类型 // 简写 toString.call({}); // \u0026#34;[object Object]\u0026#34; toString.call([]); // \u0026#34;[object Array]\u0026#34; Object.prototype.toString.call(2); // \u0026#34;[object Number]\u0026#34; Object.prototype.toString.call(\u0026#34;\u0026#34;); // \u0026#34;[object String]\u0026#34; Object.prototype.toString.call(true); // \u0026#34;[object Boolean]\u0026#34; Object.prototype.toString.call(undefined); // \u0026#34;[object Undefined]\u0026#34; Object.prototype.toString.call(null); // \u0026#34;[object Null]\u0026#34; Object.prototype.toString.call(function () {}); // \u0026#34;[object Function]\u0026#34; Object.prototype.toString.call(Math); // \u0026#34;[object Math]\u0026#34; // 对象 Object.prototype.toString.call(new Error()); // \u0026#39;[object Error]\u0026#39; Object.prototype.toString.call(new Date()); // \u0026#39;[object Date]\u0026#39; Object.prototype.toString.call(new RegExp()); // \u0026#39;[object RegExp]\u0026#39; 判断变量是否为数组 Array.isArray(arr); // true arr.__proto__ === Array.prototype; // true arr instanceof Array; // true Object.prototype.toString.call(arr); // \u0026#34;[object Array]\u0026#34; 其他 {}.toString() // 报错 没有原型链了吧 [].toString() // \u0026#34;\u0026#34; ","permalink":"https://huing.github.io/posts/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/","summary":"js 8 种数据类型 undefined null string number boolean symbol bigint object array function regexp date 数据类型判断方法 typeof 可以判断值类型，函数 typeof 0; // number typeof \u0026#34;ss\u0026#34;; // string typeof undefined; // undefined typeof true; // boolean typeof 2n; // bigint es6新增数据类型 typeof Symbol(\u0026#34;a\u0026#34;); // symbol es6新增数据类型 typeof function () {}; // function typeof null; // object 被认为是对象的占位符,但从技术上来说，它仍然是原始值 typeof []; // object typeof {}; // object instanceof 能判断对象类型 [] instanceof Array; //true [] instanceof Object; // true [].","title":"数据类型及判断方法"},{"content":"useEffect https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\nhttps://react.iamkasong.com/hooks/useref.html#commit%E9%98%B6%E6%AE%B5\nReact 工程化\nScheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler\nReconciler（协调器）—— 负责找出变化的组件\nRenderer（渲染器）—— 负责将变化的组件渲染到页面上\n虚拟 DOM 在 react 中的正式称呼 Fiber（纤程）\nFiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。\n在很多文章中将纤程理解为协程的一种实现。在 JS 中，协程的实现便是 Generator。\n所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在 JS 中的体现。\nReact Fiber 可以理解为：\nReact 内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。\n其中每个任务更新单元为 React Element 对应的 Fiber 节点。\n当我们用 canvas 绘制动画，每一帧绘制前都会调用 ctx.clearRect 清除上一帧的画面。\n如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。\n为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。\n这种在内存中构建并直接替换的技术叫做双缓存 (opens new window)。\nReact 使用“双缓存”来完成 Fiber 树的构建与替换——对应着 DOM 树的创建与更新。\n","permalink":"https://huing.github.io/posts/react/react%E5%B7%A5%E7%A8%8B%E5%8C%96/","summary":"useEffect https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\nhttps://react.iamkasong.com/hooks/useref.html#commit%E9%98%B6%E6%AE%B5\nReact 工程化\nScheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler\nReconciler（协调器）—— 负责找出变化的组件\nRenderer（渲染器）—— 负责将变化的组件渲染到页面上\n虚拟 DOM 在 react 中的正式称呼 Fiber（纤程）\nFiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。\n在很多文章中将纤程理解为协程的一种实现。在 JS 中，协程的实现便是 Generator。\n所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在 JS 中的体现。\nReact Fiber 可以理解为：\nReact 内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。\n其中每个任务更新单元为 React Element 对应的 Fiber 节点。\n当我们用 canvas 绘制动画，每一帧绘制前都会调用 ctx.clearRect 清除上一帧的画面。\n如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。\n为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。\n这种在内存中构建并直接替换的技术叫做双缓存 (opens new window)。\nReact 使用“双缓存”来完成 Fiber 树的构建与替换——对应着 DOM 树的创建与更新。","title":"React工程化"}]